C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN .\communication.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE ..\Library\communication.c COMPACT ROM(COMPACT) OPTI
                    -MIZE(8,SPEED) BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND PRINT(.\communication.lst) TABS(3) OBJECT(.\communication.obj
                    -)

line level    source

   1          /*---------------------------------------------------
   2             communication.c (v1.00)
   3             
   4             通信程序
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "communication.h"
  11          #include "Delay.h"
  12          #include "uart.h"
  13          
  14          /*------ private variable --------------------------*/
  15          tByte myTxRxData[7] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  16          //tByte IDkey11 = IDkey6^IDkey7^IDkey8^IDkey9^IDkey10;
  17          
  18          /*------- Public variable declarations --------------------------*/
  19          extern tByte receive_LV_count;      
  20          extern bit receive_wire_flag;    
  21          extern tByte one_receive_byte;      
  22          extern tByte one_receive_byte_count;         
  23          extern tByte receive_HV_count;      
  24          extern tByte data_count;            
  25          extern tByte received_data_buffer[7];     
  26          extern bit receive_data_finished_flag;    
  27          
  28          #ifdef Debug
                 extern tByte IDkey6;
                 extern tByte IDkey7;
                 extern tByte IDkey8;
                 extern tByte IDkey9;
                 extern tByte IDkey10;
              #else
  35             extern code tByte IDkey6;
  36             extern code tByte IDkey7;
  37             extern code tByte IDkey8;
  38             extern code tByte IDkey9;
  39             extern code tByte IDkey10;
  40          #endif
  41          
  42          /*----------------------------------------------------
  43             InitTransceiver()
  44             Initialise Transceiver
  45          ----------------------------------------------------*/
  46          void InitTransceiver(void)
  47             {
  48   1         P10 = High;
  49   1         transmiter_EN = Close;
  50   1         receiver_EN = Open;  
  51   1      // transmiter_power = 0;      // High power mode
  52   1         }
  53             
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 2   

  54          /*----------------------------------------------------
  55             initsignal()   
  56             初始化信号程序，接收机在接接收信号的时候，需要有
  57             一段代码来使接收机打开，而这一段程序有可能无法识别
  58             出来，而是相当于废代码，只占用通信时间。
  59          ----------------------------------------------------*/
  60          void initsignal()
  61             {
  62   1         tByte k,k1;
  63   1         tByte mystartbuffer = 0xaa;
  64   1         for(k1 = 0; k1 < 1; k1++)
  65   1            {
  66   2            for(k=0;k<8;k++)
  67   2               {
  68   3               if((mystartbuffer&0x80) == 0x80)//为1
  69   3                  {
  70   4                  P10=0;
  71   4                  Custom_Delay(46, 20);
  72   4      //          Delay_5ms();
  73   4                  }
  74   3               else
  75   3                  {
  76   4                  P10=0;
  77   4                  Custom_Delay(46, 20);
  78   4      //          Delay_5ms();
  79   4                  }
  80   3               P10=1;
  81   3               mystartbuffer<<=1;
  82   3               Custom_Delay(40, 24);
  83   3      //       Delay_5ms();
  84   3               }
  85   2            mystartbuffer=0xaa;
  86   2      //    Delay_5ms();
  87   2      //    Custom_Delay(23, 28);
  88   2            }
  89   1         P10=1;
  90   1         }
  91          
  92          void initsignal_F(void)
  93             {
  94   1         tByte k,k1;
  95   1         tByte mystartbuffer = 0xaa;
  96   1         for(k1 = 0; k1 < 1; k1++)
  97   1            {
  98   2            #ifdef Z2
  99   2            for(k=0;k<4;k++)
 100   2            #endif
 101   2            #ifdef Z3
                    for(k=0;k<7;k++)
                    #endif      
 104   2               {
 105   3               if((mystartbuffer&0x80) == 0x80)//为1
 106   3                  {
 107   4                  P10=0;
 108   4                  Custom_Delay(46, 20);
 109   4      //          Delay_5ms();
 110   4                  }
 111   3               else
 112   3                  {
 113   4                  P10=0;
 114   4                  Custom_Delay(46, 20);
 115   4      //          Delay_5ms();
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 3   

 116   4                  }
 117   3               P10=1;
 118   3               mystartbuffer<<=1;
 119   3               Custom_Delay(40, 24);
 120   3      //       Delay_5ms();
 121   3               }
 122   2            mystartbuffer=0xaa;
 123   2      //    Delay_5ms();
 124   2      //    Custom_Delay(23, 28);
 125   2            }
 126   1         P10=1;
 127   1         }
 128          
 129          /*--------------------------------------------------
 130             Send_Data()
 131             将数据发送出去
 132          --------------------------------------------------*/
 133          void Send_Data(tByte x)
 134             {
 135   1         tByte i,n;
 136   1         for(i=0;i<3;i++)
 137   1            {
 138   2            for(n=0;n<8;n++)
 139   2               {
 140   3               if((myTxRxData[i]&0x80)==0x80)
 141   3                  {
 142   4                  P10=0;
 143   4                  Custom_Delay(36, x);
 144   4                  }
 145   3               else
 146   3                  {
 147   4                  P10=0;
 148   4                  Custom_Delay(23, x);
 149   4                  }
 150   3               P10=1;
 151   3               myTxRxData[i]<<=1;
 152   3               Custom_Delay(20, x);
 153   3               }
 154   2            }  
 155   1         }
 156          
 157          /*--------------------------------------------------
 158             ComMode_Data()
 159             
 160             主机接收到编码1信号后，会反馈一个编码1信号给附机
 161             以表示主机在附机附近。
 162          ---------------------------------------------------*/
 163          void ComMode_Data(tByte ComMode, x) 
 164             {
 165   1         receiver_EN = 1;
 166   1         Delay(20);
 167   1         transmiter_EN = 0;
 168   1         myTxRxData[0] = CmdHead;
 169   1         myTxRxData[1] = MyAddress;
 170   1         myTxRxData[2] = ComMode;
 171   1      
 172   1         initsignal();
 173   1         Send_Data(x);
 174   1         
 175   1         transmiter_EN = 1;
 176   1         receiver_EN = 1;
 177   1         }
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 4   

 178          
 179          /*--------------------------------------------------
 180             ComMode_Data_WX()
 181             
 182             主机接收到编码1信号后，会反馈一个编码1信号给附机
 183             以表示主机在附机附近。
 184          ---------------------------------------------------*/
 185          void ComMode_Data_WX(tByte ComMode, x) 
 186             {
 187   1         receiver_EN = 1;
 188   1         Delay(20);
 189   1         transmiter_EN = 0;
 190   1         myTxRxData[0] = CmdHead;
 191   1         myTxRxData[1] = MyAddress;
 192   1         myTxRxData[2] = ComMode;
 193   1      
 194   1         initsignal();
 195   1         Send_Data(x);
 196   1         
 197   1         transmiter_EN = 0;
 198   1         receiver_EN = 0;
 199   1         TXD = 0;
 200   1         }
 201          
 202          /*------------------------------------------------------------------
 203             UART发送数据
 204          ------------------------------------------------------------------*/
 205          void UART_Send_Data(tByte command)
 206             {
 207   1         tByte ii = 0;
 208   1         open_tranceiver();
 209   1         myTxRxData[0] = IDkey6;
 210   1         myTxRxData[1] = IDkey7;
 211   1         myTxRxData[2] = IDkey8;
 212   1         myTxRxData[3] = IDkey9;
 213   1         myTxRxData[4] = IDkey10;
 214   1         myTxRxData[5] = command;
 215   1         
 216   1         initsignal();
 217   1         
 218   1         for(ii = 0; ii < 160; ii++)
 219   1            {
 220   2            SendNByte(myTxRxData, 6);
 221   2            Delay_10ms();     
 222   2            }
 223   1      
 224   1         close_tranceiver();
 225   1         Delay_500ms();
 226   1         }
 227          
 228          /*------------------------------------------------------------------
 229             UART附机发送数据
 230          ------------------------------------------------------------------*/
 231          void UART_Send_Data_F(tByte command)
 232             {
 233   1         tByte ii = 0;
 234   1         open_tranceiver_F();
 235   1      
 236   1         myTxRxData[0] = IDkey6;
 237   1         myTxRxData[1] = IDkey7;
 238   1         myTxRxData[2] = IDkey8;
 239   1         myTxRxData[3] = IDkey9;
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 5   

 240   1         myTxRxData[4] = IDkey10;
 241   1         myTxRxData[5] = command;
 242   1      
 243   1         initsignal_F();   
 244   1         
 245   1         SendNByte(myTxRxData, 6);
 246   1      
 247   1         receiver_EN = 0;
 248   1         close_tranceiver_F();
 249   1      
 250   1         }
 251          
 252          /*------------------------------------------------------------------
 253             UART附机发送数据
 254          ------------------------------------------------------------------*/
 255          void UART_Send_Data_F2(tByte command)
 256             {
 257   1         tByte ii = 0;
 258   1         open_tranceiver_F();
 259   1         myTxRxData[0] = IDkey6;
 260   1         myTxRxData[1] = IDkey7;
 261   1         myTxRxData[2] = IDkey8;
 262   1         myTxRxData[3] = IDkey9;
 263   1         myTxRxData[4] = IDkey10;
 264   1         myTxRxData[5] = command;
 265   1         
 266   1         Delay_1ms();
 267   1         Delay_1ms();
 268   1         Delay_1ms();
 269   1         SendNByte(myTxRxData, 6);
 270   1      
 271   1         receiver_EN = 0;
 272   1         
 273   1         close_tranceiver_F();
 274   1         }
 275          
 276          /*------------------------------------------------------------------
 277             UART附机发送数据
 278          ------------------------------------------------------------------*/
 279          void UART_Send_Data_F3(tByte command)
 280             {
 281   1         tByte ii = 0;
 282   1         myTxRxData[0] = IDkey6;
 283   1         myTxRxData[1] = IDkey7;
 284   1         myTxRxData[2] = IDkey8;
 285   1         myTxRxData[3] = IDkey9;
 286   1         myTxRxData[4] = IDkey10;
 287   1         myTxRxData[5] = command;
 288   1         
 289   1         Delay_1ms();
 290   1         Delay_1ms();
 291   1         Delay_1ms();
 292   1         SendNByte(myTxRxData, 6);
 293   1         }
 294          
 295          /*------------------------------------------------------------------
 296             open_tranceiver()
 297             开发射机
 298          -------------------------------------------------------------------*/
 299          void open_tranceiver(void)
 300             {
 301   1         #ifdef Z3
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 6   

                 InitUART(BAUD1200);
                 #endif
 304   1         
 305   1         receiver_EN = 1;
 306   1         transmiter_EN = 0;   
 307   1         }
 308          
 309          /*------------------------------------------------------------------
 310             open_tranceiver_F()
 311             开发射机
 312          -------------------------------------------------------------------*/
 313          void open_tranceiver_F(void)
 314             {
 315   1         InitUART(BAUD9600);
 316   1         
 317   1         receiver_EN = 1;
 318   1         transmiter_EN = 0;   
 319   1         }
 320          
 321          /*------------------------------------------------------------------
 322             close_tranceiver()
 323             开发射机
 324          -------------------------------------------------------------------*/
 325          void close_tranceiver(void)
 326             {
 327   1         #ifdef F3
                 transmiter_EN = 1;
                 #endif
 330   1         
 331   1         receiver_EN = 0;
 332   1         
 333   1         #ifdef Z3
                 InitUART(BAUD9600);
                 #endif
 336   1         }
 337          /*------------------------------------------------------------------
 338             close_tranceiver_F()
 339             开发射机
 340          -------------------------------------------------------------------*/
 341          void close_tranceiver_F(void)
 342             {
 343   1         #ifdef F3
                 transmiter_EN = 1;
                 #endif
 346   1         
 347   1         receiver_EN = 0;
 348   1         
 349   1         InitUART(BAUD1200);
 350   1         }
 351          
 352          /*------------------------------------------------------------------
 353             UART发送数据
 354             发送密码，用于主机
 355          ------------------------------------------------------------------*/
 356          void UART_Send_Data_match(void)
 357             {
 358   1         open_tranceiver();
 359   1         
 360   1         myTxRxData[0] = CmdHead;
 361   1         myTxRxData[1] = ComMode_1;
 362   1         myTxRxData[2] = IDkey6;
 363   1         myTxRxData[3] = IDkey7;
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 7   

 364   1         myTxRxData[4] = IDkey8;
 365   1         myTxRxData[5] = IDkey9;
 366   1         myTxRxData[6] = IDkey10;
 367   1         
 368   1         initsignal();
 369   1         
 370   1         SendNByte(myTxRxData, 8);
 371   1         Delay_50ms();
 372   1         
 373   1         close_tranceiver();
 374   1         }
 375          
 376          /*------------------------------------------------------------------
 377             UART_Send_Data_match_F发送数据
 378             发送密码，用于主机
 379          ------------------------------------------------------------------*/
 380          void UART_Send_Data_match_F(void)
 381             {
 382   1         receiver_EN = 1;
 383   1         transmiter_EN = 0;   
 384   1         InitUART(BAUD9600);
 385   1         
 386   1         myTxRxData[0] = CmdHead;
 387   1         myTxRxData[1] = ComMode_1;
 388   1         myTxRxData[2] = IDkey6;
 389   1         myTxRxData[3] = IDkey7;
 390   1         myTxRxData[4] = IDkey8;
 391   1         myTxRxData[5] = IDkey9;
 392   1         myTxRxData[6] = IDkey10;
 393   1         
 394   1         initsignal();
 395   1         
 396   1         SendNByte(myTxRxData, 8);
 397   1         Delay_50ms();
 398   1         
 399   1         receiver_EN = 0;
 400   1         }
 401          
 402          /*-----------------------------------------------------------------------------
 403             receive_byte()
 404             receive a byte program
 405          -----------------------------------------------------------------------------*/
 406          void receive_byte(void)
 407             {
 408   1         // P11 constantly HV, if detected a LV, judge it.
 409   1         if(P11 == 0)
 410   1            {
 411   2            // count the LV time, if more than 12ms, reset it.
 412   2            if(++receive_LV_count >= 120)
 413   2               {
 414   3               receive_LV_count = 0;
 415   3               }
 416   2            receive_wire_flag = 0;
 417   2            }
 418   1         // if P11 return to HV
 419   1         else
 420   1            {
 421   2            // and already have LV before, so we think it maybe a bit signal
 422   2            if(receive_wire_flag == 0)
 423   2               {
 424   3               // set the flag, to judge a bit only one time
 425   3               receive_wire_flag = 1;
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 8   

 426   3      
 427   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 428   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 429   3                  {
 430   4                  // save "0" to one byte
 431   4                  one_receive_byte <<= 1;
 432   4                  one_receive_byte &= 0xfe;
 433   4                  one_receive_byte_count++;
 434   4                  receive_HV_count = 0;
 435   4                  }
 436   3               // time > 8ms, means a "1"
 437   3               else if((receive_LV_count > 80))
 438   3                  {
 439   4                  // save "1" to one byte
 440   4                  one_receive_byte <<= 1;
 441   4                  one_receive_byte |= 0x01;
 442   4                  one_receive_byte_count++;
 443   4                  receive_HV_count = 0;
 444   4                  }        
 445   3               else
 446   3                  {
 447   4                  // increase the count for HV
 448   4                  receive_HV_count++;  
 449   4                  }
 450   3               // reset LV count
 451   3               receive_LV_count = 0;
 452   3               }
 453   2            else
 454   2               {
 455   3               // judge whether HV count > 6ms, if yes, means a restart
 456   3               if(++receive_HV_count >= 60)
 457   3                  {
 458   4                  one_receive_byte_count = 0;
 459   4                  receive_wire_flag = 1;
 460   4                  data_count = 0;
 461   4                  }     
 462   3               }
 463   2            }
 464   1         }
 465          
 466          /*-----------------------------------------------------------------------------
 467             receive_byte_Lock()
 468             receive a byte program
 469          -----------------------------------------------------------------------------*/
 470          void receive_byte_Lock(void)
 471             {
 472   1         // P11 constantly HV, if detected a LV, judge it.
 473   1         if(receive_wire == 1)
 474   1            {
 475   2            // count the LV time, if more than 12ms, reset it.
 476   2            if(++receive_LV_count >= 120)
 477   2               {
 478   3               receive_LV_count = 0;
 479   3               }
 480   2            receive_wire_flag = 0;
 481   2            }
 482   1         // if P11 return to HV
 483   1         else
 484   1            {
 485   2            // and already have LV before, so we think it maybe a bit signal
 486   2            if(receive_wire_flag == 0)
 487   2               {
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 9   

 488   3               // set the flag, to judge a bit only one time
 489   3               receive_wire_flag = 1;
 490   3      
 491   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 492   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 493   3                  {
 494   4                  // save "0" to one byte
 495   4                  one_receive_byte <<= 1;
 496   4                  one_receive_byte &= 0xfe;
 497   4                  one_receive_byte_count++;
 498   4                  receive_HV_count = 0;
 499   4                  }
 500   3               // time > 8ms, means a "1"
 501   3               else if((receive_LV_count > 80))
 502   3                  {
 503   4                  // save "1" to one byte
 504   4                  one_receive_byte <<= 1;
 505   4                  one_receive_byte |= 0x01;
 506   4                  one_receive_byte_count++;
 507   4                  receive_HV_count = 0;
 508   4                  }        
 509   3               else
 510   3                  {
 511   4                  // increase the count for HV
 512   4                  receive_HV_count++;  
 513   4                  }
 514   3               // reset LV count
 515   3               receive_LV_count = 0;
 516   3               }
 517   2            else
 518   2               {
 519   3               // judge whether HV count > 6ms, if yes, means a restart
 520   3               if(++receive_HV_count >= 60)
 521   3                  {
 522   4                  one_receive_byte_count = 0;
 523   4                  receive_wire_flag = 1;
 524   4                  data_count = 0;
 525   4                  }     
 526   3               }
 527   2            }
 528   1         }
 529          
 530          /*-----------------------------------------------------------------------------
 531             receive_word()
 532             receive a word program
 533          -----------------------------------------------------------------------------*/
 534          void receive_word(void)
 535             {
 536   1         // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 537   1         if(one_receive_byte_count == 8)
 538   1            {
 539   2            one_receive_byte_count = 0;
 540   2            // assign one byte to buffer[i] 
 541   2            received_data_buffer[data_count] = one_receive_byte;
 542   2            
 543   2            // judge whether buffer[0] is CmdHead
 544   2            if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 545   2               {
 546   3               data_count = 1;
 547   3               }
 548   2            // judge whether buffer[1] is MyAddress
 549   2            else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 10  

 550   2               {
 551   3               data_count = 2;
 552   3               }
 553   2            else if(data_count == 2)
 554   2               {
 555   3               receive_data_finished_flag = 1;
 556   3               data_count = 0;
 557   3               }
 558   2            else 
 559   2               {
 560   3               data_count = 0;
 561   3               }
 562   2            }
 563   1         }
 564          
 565          /*--------------------------------------------------
 566             send_code_to_lock()
 567             
 568             将密码发送给锁体。
 569          ---------------------------------------------------*/
 570          void send_code_to_lock(tByte x, y)  
 571          {
 572   1         unsigned char i,n;
 573   1         myTxRxData[0]=CmdHead;
 574   1         myTxRxData[1]=MyAddress;
 575   1         myTxRxData[2]=x;
 576   1      /* myTxRxData[3]=0x00;
 577   1         myTxRxData[4]=0x00;
 578   1         myTxRxData[5]=0x00;
 579   1         myTxRxData[6]=0x00;
 580   1      */
 581   1         for(i=0;i<3;i++)
 582   1         {
 583   2            for(n=0;n<8;n++)
 584   2            {
 585   3               if((myTxRxData[i]&0x80) == 0x80)//为1
 586   3               {
 587   4                  MagentControl_2 = 0;
 588   4                  Custom_Delay(36, y);
 589   4               }
 590   3               else//为0的情况
 591   3               {
 592   4                  MagentControl_2 = 0;
 593   4                  Custom_Delay(23, y);
 594   4               }
 595   3               MagentControl_2 = 1;    //常态为高电平
 596   3               myTxRxData[i] <<= 1;
 597   3               Custom_Delay(15, y);
 598   3            }
 599   2         }
 600   1      }
 601          
 602          /*--------------------------------------------------
 603             send_code_to_lock_Taili()
 604             
 605             将密码发送给锁体。
 606          ---------------------------------------------------*/
 607          void send_code_to_lock_Taili(tByte x, y)  
 608          {
 609   1         unsigned char i,n;
 610   1         myTxRxData[0]=CmdHead;
 611   1         myTxRxData[1]=MyAddress;
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 11  

 612   1         myTxRxData[2]=x;
 613   1      /* myTxRxData[3]=0x00;
 614   1         myTxRxData[4]=0x00;
 615   1         myTxRxData[5]=0x00;
 616   1         myTxRxData[6]=0x00;
 617   1      */
 618   1         for(i=0;i<3;i++)
 619   1         {
 620   2            for(n=0;n<8;n++)
 621   2            {
 622   3               if((myTxRxData[i]&0x80) == 0x80)//为1
 623   3               {
 624   4                  lock_code = 0;
 625   4                  Custom_Delay(36, y);
 626   4               }
 627   3               else//为0的情况
 628   3               {
 629   4                  lock_code = 0;
 630   4                  Custom_Delay(23, y);
 631   4               }
 632   3               lock_code = 1;    //常态为高电平
 633   3               myTxRxData[i] <<= 1;
 634   3               Custom_Delay(15, y);
 635   3            }
 636   2         }
 637   1      }
 638          
 639          /*------------------------------------------------------------------
 640             UART发送数据
 641          ------------------------------------------------------------------*/
 642          void UART_Send_Data_Broadtest(tByte command)
 643             {
 644   1         tByte ii = 0;
 645   1      // open_tranceiver();
 646   1      
 647   1         myTxRxData[0] = IDkey6;
 648   1         myTxRxData[1] = IDkey7;
 649   1         myTxRxData[2] = IDkey8;
 650   1         myTxRxData[3] = IDkey9;
 651   1         myTxRxData[4] = IDkey10;
 652   1         myTxRxData[5] = command;
 653   1         
 654   1         initsignal();
 655   1         
 656   1         for(ii = 0; ii < 10; ii++)
 657   1            {
 658   2            SendNByte(myTxRxData, 6);
 659   2            Delay_10ms();     
 660   2            }
 661   1      
 662   1      // close_tranceiver();
 663   1      // Delay_500ms();
 664   1         }
 665          
 666          
 667          /*---------------------------------------------------
 668             end of file
 669          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1358    ----
C51 COMPILER V9.54   COMMUNICATION                                                         01/04/2017 15:10:32 PAGE 12  

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      7      31
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
