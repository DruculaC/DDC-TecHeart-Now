C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE Main.c COMPACT ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDI
                    -R(..\Library) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*---------------------------------------------------
   2            main.c (v1.00)
   3          
   4            DDC-Z program, for electrocar.
   5          ----------------------------------------------------*/
   6          
   7          //
   8          #include "Main.h"
   9          #include "port.h"
  10          
  11          #include "AD.h"
  12          #include "voice.h"
  13          //#include "pwm.h"
  14          #include "Timer.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          #include "Battery.h"
  18          #include "Other.h"
  19          #include "operation.h"
  20          #include "UART.h"
  21          #include "ISP_DataFlash.h"
  22          #include "schedular.h"
  23          #include "ElecMotor.h"
  24          
  25          
  26          /*------- Public variable declarations --------------------------*/
  27          extern tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;
  28          extern bit enable_sensor_delayEN;
  29          extern bit sensor_EN;
  30          
  31          /*------- Public variable definitions --------------------------*/
  32          bit ID_certificated_flag = 0;     // Flagged once ID card or Slave certificated successfully.
  33          tByte ID_certificated_numbers = 0;  // Numbers of ID certificated.
  34          
  35          bit Host_stolen_alarming = 0;     // Host stolen is alarming, don't detect vibration for 1st stage.
  36          
  37          // ------ Private variable definitions -----------------------------
  38          bit position_sensor_EN=0;     //Œª÷√¥´∏–∆˜£¨º¥µπµÿÃß∆¥´∏–∆˜◊‹ø™πÿ£¨1µƒ ±∫Ú£¨ºÏ≤‚’‚¡Ω∏ˆ¥´∏–∆˜
  39          bit EN_host_stolen_alarming = 0;      //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄“ª∂Œ”Ô“Ù πƒ‹
  40          bit host_stolen_alarm2_EN = 0;      //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄∂˛∂Œ”Ô“Ù πƒ‹
  41          tByte host_stolen_alarm1_count = 0;   //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄“ª∂Œ”Ô“Ù¥Œ ˝
  42          tByte host_stolen_alarm2_count = 0;   //≈–∂œŒ™±ªµ¡±®æØ∫Ûµƒµ⁄∂˛∂Œ”Ô“Ù¥Œ ˝
  43          bit fell_flag=0;            //≈–∂œ÷˜ª˙µπœ¬∫Û£¨÷√1
  44          bit raised_flag=0;          //≈–∂œ÷˜ª˙±ªÃß∆∫Û£¨÷√1
  45          tByte sensor_2ndstage_count = 0;    //¥´∏–∆˜Ω¯»Îµ⁄∂˛Ω◊∂ŒºÏ≤‚ ±£¨º∆À„µÕµÁ∆Ωµƒ ±º‰
  46          tWord sensor_3rdstage_time = 0;     //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œµƒ ±º‰£¨
  47          tByte sensor_3rdstage_effcount = 0;   //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œ∫Û£¨”––ß¥•≈ˆ¥Œ ˝µƒº∆ ˝
  48          tByte sensor_3rdstage_count = 0;      //¥´∏–∆˜Ω¯»Îµ⁄»˝Ω◊∂Œ∫Û£¨µÕµÁ∆Ωµƒº∆ ˝
  49          tWord sensor_3rdstage_interval = 0;   //¥´∏–∆˜‘⁄µ⁄»˝Ω◊∂Œ÷–£¨√ø¥Œ”––ßµÕµÁ∆Ωº∆ ˝÷Æº‰µƒ ±º‰º‰∏Ù°£‘⁄’‚∆⁄º‰µƒµÕµ
             -Á∆Ω≤ª»œŒ™”––ß°£
  50          bit raised_fell_flag = 0;         //µπµÿªÚ’ﬂÃß∆¥•∑¢∫Û£¨¥À±Í÷æŒª÷√1
  51          tByte sensor_trigger_count=0;   //¥´∏–∆˜¥•∑¢º∆ ˝
  52          tWord sensor_2ndstage_time=0;   //¥´∏–∆˜Ω¯»Îµ⁄∂˛Ω◊∂Œ∫Û¡˜ ≈ ±º‰µƒº∆ ˝
  53          tByte sensor_1ststage_count=0;  //¥´∏–∆˜µ⁄“ªΩ◊∂Œ≈–∂œµÕµÁ∆Ωµƒº∆ ˝
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 2   

  54          
  55          tByte raised_alarm_count = 0;    //÷˜ª˙±ªÃß∆∫Û£¨œÚ∏Ωª˙∑¢≥ˆ±®æØ–≈∫≈µƒ¥Œ ˝
  56          tByte fell_alarm_count = 0;        //÷˜ª˙µπµÿ∫Û£¨œÚ∏Ωª˙∑¢≥ˆ±®æØ–≈∫≈µƒ¥Œ ˝
  57          tWord timer0_count=0;   // counter for timer0, increment every ticket       
  58          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //Ω” ’ ˝æ›ª∫¥Ê
  59          bit receive_data_finished_flag = 0;   //Ω” ’’‚“ª¥Æ ˝æ›ÕÍ≥…∫Û£¨¥À±Í÷æŒª÷√1
  60          tByte data_count = 0;       //Ω” ’ ˝æ›ª∫¥ÊµƒŒª ˝£¨º¥±Ì√˜µ⁄º∏∏ˆª∫¥Ê ˝æ›
  61          tByte one_receive_byte = 0;   //Ω” ’ ˝æ›µƒ“ª∏ˆ◊÷Ω⁄£¨Ω” ’ÕÍ∫ÛΩ´∆‰∏≥÷µ∏¯received_data_bufferœ‡∂‘”¶µƒ◊÷Ω⁄
  62          tByte one_receive_byte_count = 0;     //one_receive_byte”–8Œª£¨¥Àº∆ ˝±Ì√˜Ω” ’µΩµ⁄º∏Œª£¨√ø¥Œº∆ ˝µΩ8µƒ ±∫Ú±Ì√˜
             -“ª∏ˆ◊÷Ω⁄Ω” ’ÕÍ≥…°£
  63          bit receive_wire_flag = 1;    //Ω” ’Õ®–≈œﬂµƒ±Í÷æŒª£¨1±Ì√˜∏ﬂµÁ∆Ω£¨0±Ì√˜µÕµÁ∆Ω£¨√ø¥Œtimer1“Á≥ˆ ±£¨≈–∂œP1.1“ª¥Œ
             -°£“‘¥À¿¥±Ì√˜ «∑ÒŒ™“ª¥Œ’˝»∑µƒœ¬Ωµ—ÿ
  64          tByte receive_HV_count = 0;   //∂® ±∆˜T1‘⁄√ª”––≈∫≈µΩ¿¥µƒ ±∫Ú£¨∂‘∏ﬂµÁ∆Ωº∆ ˝£¨“ªµ©≥¨π˝ƒ≥∏ˆ÷µ£¨‘ÚΩ´one_receive
             -_byte_count«Â0
  65          tByte receive_LV_count = 0;   //√ø¥Œtimer1“Á≥ˆ ±≈–∂œΩ” ’œﬂ»Áπ˚Œ™LV£¨‘Úº∆ ˝º”1£¨“‘¥À¿¥±Ì√˜µÕµÁ∆Ωµƒ ±º‰
  66          tByte fell_wire_time=0;         //µπµÿºÏ≤‚œﬂ£¨ºÏ≤‚µÕµÁ∆Ωµƒ ±º‰
  67          tByte raise_wire_time=0;      //Ãß∆ºÏ≤‚œﬂ£¨ºÏ≤‚µÕµÁ∆Ωµƒ ±º‰
  68          tWord raised_fell_number = 0;       //µπµÿªÚ’ﬂÃß∆≥ˆ∑¢∫Û£¨º∆ ˝£¨µΩ¥Ô“ª∂® ˝÷µ∫Û£¨Ω´∆‰”Î±Í÷æŒª“ª∆«Â¡„°£
  69          bit raised_fell_once_flag = 0;      //raised_fell_flag «∑Ò‘¯æ≠±Í÷æπ˝£¨»Áπ˚±Í÷æπ˝‘Ú÷√1.»ª∫Û÷˜ª˙±ªª÷∏¥µπµÿªÚ’ﬂª
             -÷∏¥Ãß∆ ±£¨¥À±Í÷æŒª∏¥Œª°£
  70          tByte Open_action_flag = 0;     //µÁ∂Ø≥µø™∆Ùπÿ±’±Í÷æŒª£¨1±Ì æµÁ∂Ø≥µø™∆Ù¡À£¨0±Ì æµÁ∂Ø≥µπÿ±’¡À
  71          tWord ADC_check_result = 0;   //◊˜Œ™ADºÏ≤‚÷µ
  72          
  73          
  74          tWord load_battery_result = 0xfff;
  75          tByte wire_broken_count = 0;    // ◊˜Œ™∂œœﬂ∫Ûµƒ ±º‰ºÏ≤‚
  76          bit battery_stolen_EN = 0;      // ◊˜Œ™µÁ≥ÿ±ªµ¡µƒ πƒ‹∂À
  77          tByte battery_stolen_count = 0; // ◊˜Œ™µÁ≥ÿ±ªµ¡µƒ±®æØ¥Œ ˝
  78          bit horizontal_vibration = 0;   // ±Ì æ¥π÷±¥´∏–∆˜‘⁄’Ò∂Ø£¨¥À ±æÕÀ„πÿ‘ø≥◊£¨“≤≤ªƒ‹÷¥––πÿ‘ø≥◊µƒ≤Ÿ◊˜°
  79          tWord horizontal_vibration_count = 0; //¥π÷±¥´∏–∆˜¥•∑¢∫Û£¨∂‘ ±º‰Ω¯––º∆ ˝°£
  80          bit vibration_flag = 0;
  81          tWord vibration_count = 0;
  82          bit wire_broken_flag = 0;     // ºÙ∂œÀ¯œﬂµƒ±Í÷æŒª
  83          tByte After_IDcert_timecount = 0;   // IDø®»œ÷§Õ®π˝∫Û£¨º∆ ±1∑÷÷”£¨ π‘ø≥◊ƒ‹◊™∂Ø°£
  84          tByte enable_sensor_delay_count = 0;    // ¥´∏–∆˜—”≥Ÿµƒ ±º‰
  85          bit sensor_3rdalarm_flag = 0;
  86          bit wheeled_flag = 0;
  87          tWord wheeled_count = 0;
  88          bit IDkey_speech_flash = 0;
  89          bit Emergency_open_G = 0;
  90          
  91          bit Speech_closed_G = 0;
  92          tByte Speech_closed_time = 0;
  93          
  94          // If it is a debug program, define IDkey6~11 to RAM
  95          #ifdef Debug
                tByte IDkey6;
                tByte IDkey7;
                tByte IDkey8;
                tByte IDkey9;
                tByte IDkey10;
                tByte IDkey11;
              // If it is a normal program, define IDkey6~11 to Flash ROM
              #else
 104            code tByte IDkey6 _at_ 0x003000;
 105            code tByte IDkey7 _at_ 0x003001;
 106            code tByte IDkey8 _at_ 0x003002;
 107            code tByte IDkey9 _at_ 0x003003;
 108            code tByte IDkey10 _at_ 0x003004;
 109            code tByte IDkey11 _at_ 0x003005;
 110          #endif
 111          
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 3   

 112          tWord IDkey_selflearn_HVcount = 0;
 113          tWord IDkey_selflearn_LVcount = 0;
 114          bit IDkey_selflearn_flag1 = 0;
 115          bit IDkey_selflearn_flag2 = 0;
 116          bit IDkey_selflearn_flag3 = 0;
 117          bit IDkey_selflearn_flag4 = 0;
 118          bit IDkey_selflearn_flag5 = 0;
 119          bit ID_selflearning_flag = 0;
 120          tByte ID_selflearning_timecount = 0;
 121          bit IDkey_flash_EN = 0;
 122          
 123          bit Silence_Flag = 0;
 124          bit flashing_flag = 0;
 125          
 126          tByte Check_Motobattery_count = 0;
 127          bit Check_Motobattery_flag = 0;
 128          bit CheckADC_flag = 0;
 129          
 130          bit never_alarm = 0;
 131          bit never_alarm_speech = 0;
 132          
 133          bit slave_nearby_actioned_flag = 0;
 134          tByte slave_nearby_count = 0;
 135          
 136          bit ID_speeched_flag = 0;
 137          
 138          tByte Stolen_alarm_reset_count = 0;
 139          
 140          bit wire_broken_reset = 0;
 141          
 142          bit Just_power_up = 1;
 143          
 144          bit Battery_hint_flag = 0;
 145          
 146          bit Autolock_G = 0;
 147          tWord timer0_count2 = 0;
 148          
 149          bit Battery_flag = 0;
 150          
 151          /*------- Private variable declaratuions --------------------------*/
 152          
 153          void main()
 154            {
 155   1        InitVoice();
 156   1      
 157   1        // lock the external motor, prohibit motor moving when power up.
 158   1      //  InitElecmotor();
 159   1      
 160   1        ID_speech();
 161   1      
 162   1        InitUART(BAUD9600);
 163   1      
 164   1        InitSensor();
 165   1      
 166   1        InitTransceiver();
 167   1        
 168   1        
 169   1        // Ω´P0.1, P0.2…Ë÷√≥… ‰»Î∏ﬂ◊Ëƒ£ Ω
 170   1        P0M1 |= 0x06;
 171   1        P0M2 &= 0xf9;
 172   1        // Ω´P2.5£¨º¥PIN16…Ë÷√≥… ‰»Î∏ﬂ◊Ëƒ£ Ω
 173   1        P2M1 |= 0x20;
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 4   

 174   1        P2M2 &= 0xdf;
 175   1      
 176   1        Lock_EN = 1;
 177   1        
 178   1        // µÁª˙À¯
 179   1        Generator_lock = 0;
 180   1        Externalmotor = 1;
 181   1      
 182   1        lock_power = 0;
 183   1        
 184   1        ADC_check_result = GetADCResult(6);
 185   1      
 186   1        while(1)
 187   1          {
 188   2          }
 189   1        }
 190          
 191          /*------------------------------------------------------------------
 192            timerT0()
 193            operation every ticket.
 194          --------------------------------------------------------------------*/
 195          void timer0() interrupt interrupt_timer_0_overflow
 196            {
 197   1        // manually reload timer0 configuration
 198   1        TH0 = timer0_8H;
 199   1        TL0 = timer0_8L;
 200   1      
 201   1        // timer0 is 1ms ticket, count the time flow of timer0, then operate every 2s.
 202   1        if(++timer0_count >= 2000)
 203   1          {
 204   2          // reset timer0 ticket counter every 2s
 205   2          timer0_count=0;
 206   2      
 207   2      
 208   2      //    UART_Send_Data_match();
 209   2      
 210   2          #ifdef ID
 211   2          if((++timer0_count2 >= 35)&&(Autolock_G == 0))
 212   2            {
 213   3            Autolock_G = 1;
 214   3            }
 215   2          #endif
 216   2      /*----- Wire_cut detection ----------------------------------------*/
 217   2          if(sensor_EN == 1)
 218   2            {
 219   3            // judge the wire broken, if yes, it means someone has cut the wire of magnet lock
 220   3            if(wire_broken == 0)
 221   3              {
 222   4              EN_host_stolen_alarming = 1;
 223   4              host_stolen_alarm2_EN = 1;
 224   4              Stolen_alarm_reset_count = 0;   
 225   4              wire_broken_flag = 1;
 226   4              }
 227   3            else if((wire_broken == 1)&&(wire_broken_flag == 1))
 228   3              {
 229   4              wire_broken_reset = 1;
 230   4              wire_broken_flag = 0;       
 231   4              ID_speech();
 232   4              }
 233   3            }
 234   2      
 235   2          if(Speech_closed_G == 1)
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 5   

 236   2            {
 237   3            Speech_closed_time += 1;
 238   3            if(Speech_closed_time > 2)
 239   3              {
 240   4              Speech_closed_time = 0;
 241   4              voice_EN = 0;
 242   4              }
 243   3            }
 244   2      
 245   2      /*----- Accumulator relevantly ------------------------------------*/
 246   2          Check_motor_accumulator();
 247   2          Accumulator_voice_promot();
 248   2      
 249   2      /*----- Enable sensor ---------------------------------------------*/
 250   2          #ifdef ID
 251   2          ENsensor_afterIDcert();
 252   2          #endif
 253   2          // if no vibration and wheeled, decrease slave_nearby_count,
 254   2          // if more than 3 times, it means slave is away, then enable sensor.
 255   2          #ifdef WX
                  Ensensor_after_slave_away();
                  #endif    
 258   2      
 259   2          ENsensor_After_Close();
 260   2      
 261   2      /*----- Alarm relevantly -----------------------------------------*/
 262   2          #ifdef Z3
                  Fell_Alarm_to_Slave();
                  Raise_Alarm_to_Slave();
                  Batstolen_Alarm_to_Slave();
                  #endif
 267   2          
 268   2          Host_stolen_action();
 269   2      
 270   2      /*----- Reset flag and disabling sensor relevantly --------------*/
 271   2      
 272   2          Reset_after_wirebroken();
 273   2          Reset_after_stolen_alarming();
 274   2          SelfLearn_Reset();
 275   2          }
 276   1      
 277   1        // Voice hint for entering no guard mode,
 278   1        Enter_noguard_voice();
 279   1      
 280   1      /*----- Detectiong relevantly -----------------------------------*/
 281   1        Detect_selflearn_action();
 282   1        Detect_vibration();
 283   1        Detect_wheel_moving();
 284   1        
 285   1        Disable_sensor_after_IDcert();
 286   1      
 287   1        Detect_open_action();
 288   1        Detect_close_action();  
 289   1        
 290   1        if(Battery_hint_flag == 1)
 291   1          {
 292   2          Battery_hint_flag = 0;
 293   2          Battery_hint();
 294   2          }
 295   1      
 296   1      // judge host is fell or raised every 1ms?
 297   1      //  if((raised_sensor_detect == 1)&&(fell_sensor_detect == 1))
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 6   

 298   1      //    {
 299   1          // judge vibration sensor is enable?
 300   1          if(sensor_EN == 1)  
 301   1            {     
 302   2            // sensor trigger status, 0, 1 or 2?
 303   2            switch(sensor_trigger_count)
 304   2              {
 305   3              // case 0, it means host is in waiting status. waiting for first touch.
 306   3              case 0:
 307   3                {         
 308   4                // judge host been touched and also not in vibration alarm
 309   4      //          if((sensor_detect == 0)&&(Host_stolen_alarming == 0)&&(transmiter_EN == 1))   
 310   4      //          if(((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))&&(Host_stolen_alarming ==
             - 0)&&(flashing_flag == 0)&&(transmiter_EN == 1))    
 311   4                if(((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))&&(Host_stolen_alarming == 0
             -)&&(flashing_flag == 0))    
 312   4                  {
 313   5                  // judge LV is more than 2ms, if yes, it means a effective touch
 314   5                  if(++sensor_1ststage_count >= 1)      
 315   5                    {
 316   6                    sensor_1ststage_count=0;
 317   6                    
 318   6                    
 319   6                    sensor_2ndstage_time = 0;
 320   6                    // sensor trigge status progress to case 1.
 321   6                    sensor_trigger_count = 1;
 322   6                    // alarm speech for first touch
 323   6      //              SCH_Add_Task(host_touch_speech, 0, 0);
 324   6      
 325   6                    // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 326   6                    Generator_lock = 1;
 327   6                    // ÁîµÊú∫ÈîÅÊ≠ª
 328   6                    Externalmotor = 0;
 329   6      
 330   6                    #ifdef voice
 331   6                    //host_touch_speech();
 332   6                    #endif
 333   6                    
 334   6                    Delay_500ms();Delay_500ms();Delay_500ms();Delay_500ms();
 335   6                           }
 336   5                  }
 337   4                else
 338   4                  {
 339   5                  // if no LV, reset the count.
 340   5                  sensor_1ststage_count = 0;
 341   5                  }
 342   4                }
 343   3              break;
 344   3              
 345   3              // waiting for next touch, 
 346   3              case 1:
 347   3                {
 348   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 349   4                  {
 350   5                  // LV for 2s, means a effective touch
 351   5                  if(++sensor_2ndstage_count >= 1)
 352   5                    {
 353   6                    sensor_2ndstage_count = 0;
 354   6                    sensor_trigger_count = 2;
 355   6                    
 356   6                    sensor_3rdstage_time = 0;
 357   6                    // alarm speech for 2nd touch
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 7   

 358   6                    
 359   6                    // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 360   6                    Generator_lock = 1;
 361   6                    // ÁîµÊú∫ÈîÅÊ≠ª
 362   6                    Externalmotor = 0;
 363   6                      
 364   6                    //host_2ndtouch_speech();
 365   6                    host_touch_speech();
 366   6                    #ifdef voice
 367   6                    #endif
 368   6                    }
 369   5                  }
 370   4                else
 371   4                  {
 372   5                  sensor_2ndstage_count = 0;
 373   5                  }
 374   4      
 375   4                // if there is no touch in 4s, reset sensor trigger status, etc.
 376   4                if(++sensor_2ndstage_time >= 8000)
 377   4                  {
 378   5                  sensor_trigger_count = 0;
 379   5                  sensor_2ndstage_count = 0;
 380   5                  sensor_1ststage_count = 0;
 381   5                  sensor_2ndstage_time = 0;
 382   5      
 383   5                  // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 384   5                  Generator_lock = 0;
 385   5                  // ÁîµÊú∫ÈîÅÊ≠ª
 386   5                  Externalmotor = 1;
 387   5                  }
 388   4                }
 389   3              break;
 390   3      
 391   3              case 2:
 392   3                {
 393   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 394   4                  {
 395   5                  // LV for 2s, means a effective touch
 396   5                  if(++sensor_3rdstage_count >= 2)
 397   5                    {
 398   6                    sensor_3rdstage_count = 0;
 399   6                    sensor_trigger_count = 3;
 400   6                    sensor_3rdstage_time = 0;
 401   6      
 402   6                    // alarm speech for 2nd touch
 403   6      //              host_2ndtouch_speech();
 404   6      
 405   6                    // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 406   6                    Generator_lock = 1;
 407   6                    // ÁîµÊú∫ÈîÅÊ≠ª
 408   6                    Externalmotor = 0;
 409   6      
 410   6                    host_2ndtouch_speech();
 411   6                    #ifdef voice
 412   6                    #endif
 413   6                    }
 414   5                  }
 415   4                else
 416   4                  {
 417   5                  sensor_3rdstage_count = 0;
 418   5                  }
 419   4                  
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 8   

 420   4                // if there is no touch in 4s, reset sensor trigger status, etc.
 421   4                if(++sensor_3rdstage_time >= 8000)
 422   4                  {
 423   5                  sensor_trigger_count = 0;
 424   5                  sensor_3rdstage_count = 0;
 425   5                  sensor_2ndstage_count = 0;
 426   5                  sensor_1ststage_count = 0;
 427   5                  sensor_3rdstage_time = 0;
 428   5      
 429   5                  // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 430   5                  Generator_lock = 0;
 431   5                  // ÁîµÊú∫ÈîÅÊ≠ª
 432   5                  Externalmotor = 1;
 433   5                  }
 434   4                }
 435   3              break;
 436   3              
 437   3              // waiting for 3rd touch
 438   3              case 3:
 439   3                {
 440   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 441   4                  {
 442   5                  // 2s LV is a effective touch
 443   5                  if(++sensor_3rdstage_count >= 3)
 444   5                    {
 445   6                    sensor_3rdstage_count = 0;
 446   6                    // stolen alarm speech enable
 447   6                    EN_host_stolen_alarming = 1;
 448   6                    host_stolen_alarm2_EN = 1;  
 449   6                    sensor_3rdalarm_flag = 1; 
 450   6                    Stolen_alarm_reset_count = 0;
 451   6                    
 452   6                    // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 453   6                    Generator_lock = 1;
 454   6                    // ÁîµÊú∫ÈîÅÊ≠ª
 455   6                    Externalmotor = 0;
 456   6                    }
 457   5                  }
 458   4                else
 459   4                  {
 460   5                  sensor_3rdstage_count = 0;
 461   5                  }
 462   4                
 463   4                // if there is no touch in 4s, reset all.
 464   4                if(++sensor_3rdstage_time >= 8000)
 465   4                  {
 466   5                  sensor_trigger_count = 0;
 467   5                  sensor_1ststage_count = 0;
 468   5                  sensor_2ndstage_count = 0;
 469   5                  sensor_2ndstage_time = 0;
 470   5                  sensor_3rdstage_time = 0;
 471   5                  sensor_3rdstage_count = 0;
 472   5                  
 473   5                  if(EN_host_stolen_alarming == 0)
 474   5                    {
 475   6                    // Êä•Ë≠¶Êó∂‰ΩøÊéßÂà∂Âô®‰æõÁîµ
 476   6                    Generator_lock = 0;
 477   6                    // ÁîµÊú∫ÈîÅÊ≠ª
 478   6                    Externalmotor = 1;              
 479   6                    }
 480   5                  }
 481   4                }
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 9   

 482   3              break;
 483   3              }
 484   2            
 485   2            
 486   2            if(ADC_check_result < 0x100)
 487   2              {
 488   3              battery_stolen_EN = 1;
 489   3              }
 490   2            else
 491   2              battery_stolen_EN = 0;
 492   2              }
 493   1      //      }
 494   1        
 495   1        // judge whether position sensor is enable
 496   1        if(position_sensor_EN==1)   
 497   1          {
 498   2          // judge whether there is a LV
 499   2          if(raised_sensor_detect == 0) 
 500   2            {
 501   3            // LV > 0.5s means a effective input
 502   3            if(++raise_wire_time==10)
 503   3              {
 504   4              // flag raised, and reset fell
 505   4              raised_flag=1;
 506   4              fell_flag=0;
 507   4              // judge whether there once been a raised or fell.
 508   4              if(raised_fell_once_flag == 0)
 509   4                {
 510   5                // if no, flag raised and fell flag
 511   5                raised_fell_flag = 1;         
 512   5                }
 513   4              }   
 514   3            }
 515   2          else
 516   2            {
 517   3            raised_flag=0;
 518   3            raised_alarm_count=0;
 519   3            raise_wire_time=0;
 520   3            raised_fell_flag = 0;
 521   3            }
 522   2            // judge whether there is a LV
 523   2          if(fell_sensor_detect==0)
 524   2            {
 525   3            // LV > 0.5s means a effective input
 526   3            if(++fell_wire_time==10)  
 527   3              { 
 528   4              //  flag fell, and reset raised
 529   4              fell_flag=1;      
 530   4              raised_flag=0;
 531   4              // judge whether there once been a raised or fell
 532   4              if(raised_fell_once_flag == 0)
 533   4                {
 534   5                raised_fell_flag = 1;         
 535   5                }
 536   4              }   
 537   3            }
 538   2          else
 539   2            {
 540   3            fell_flag=0;
 541   3            fell_alarm_count=0;
 542   3            fell_wire_time=0;
 543   3            raised_fell_flag = 0;
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 10  

 544   3            }
 545   2          }
 546   1        
 547   1        // judge whether raised or fell, if yes, reset all after 10s.
 548   1        if(raised_fell_flag == 1)
 549   1          {
 550   2          if(++raised_fell_number >= 4000)
 551   2            {
 552   3            raised_fell_flag = 0;
 553   3            raised_fell_number = 0;
 554   3            raised_fell_once_flag = 1;
 555   3            
 556   3            sensor_trigger_count = 0;
 557   3            sensor_1ststage_count = 0;
 558   3            sensor_2ndstage_count = 0;
 559   3            sensor_2ndstage_time = 0;
 560   3            sensor_3rdstage_time = 0;
 561   3            sensor_3rdstage_interval = 800;
 562   3            sensor_3rdstage_count = 0;
 563   3            sensor_3rdstage_effcount = 0;         
 564   3            }
 565   2          }
 566   1        }
 567          
 568          /*-----------------------------------------------
 569            UART interrupt
 570          -----------------------------------------------*/
 571          void uart_isr() interrupt 4 
 572            {
 573   1        if(RI)
 574   1          {
 575   2          RI=0;
 576   2          received_data_buffer[data_count] = SBUF;
 577   2      
 578   2          // assign one byte to buffer[i] 
 579   2          
 580   2          if(ID_selflearning_flag == 0)
 581   2            {
 582   3            // judge whether buffer[0] is CmdHead
 583   3            if((data_count == 0) && (received_data_buffer[0] == IDkey6))
 584   3              {
 585   4              data_count = 1;
 586   4              }
 587   3            else if((data_count == 1) && (received_data_buffer[1] == IDkey7))
 588   3              {
 589   4              data_count = 2;
 590   4              }
 591   3            else if((data_count == 2) && (received_data_buffer[2] == IDkey8))
 592   3              {
 593   4              data_count = 3;
 594   4              }
 595   3            else if((data_count == 3) && (received_data_buffer[3] == IDkey9))
 596   3              {
 597   4              data_count = 4;
 598   4              }
 599   3            else if((data_count == 4) && (received_data_buffer[4] == IDkey10))
 600   3              {
 601   4              data_count = 5;
 602   4              }
 603   3            #ifdef ID
 604   3            else if((data_count == 5) && (received_data_buffer[5] == IDkey11))
 605   3              {
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 11  

 606   4              data_count = 0;
 607   4              ID_certificated_flag = 1;
 608   4              After_IDcert_timecount = 0;
 609   4              IDkey_speech_flash = 1;
 610   4              
 611   4              IDcerted_speech();
 612   4                  
 613   4              if(ID_certificated_numbers++ >= 1)
 614   4                {
 615   5                // ÈùôÈü≥Ê®°Âºè
 616   5                Silence_Flag = 1;
 617   5                }
 618   4              if(++ID_certificated_numbers >= 11)
 619   4                {
 620   5                //never_alarm = 1;
 621   5                
 622   5                // ”¶º±ø™À¯
 623   5                Emergency_open_G = ~Emergency_open_G;
 624   5                ID_certificated_flag = 1;
 625   5                never_alarm_speech = 1;
 626   5                
 627   5                Silence_Flag = 0;
 628   5                ID_certificated_numbers = 0;
 629   5                }
 630   4              }
 631   3            #endif
 632   3            #ifdef WX
                    else if(data_count == 5)
                      {
                      receive_data_finished_flag = 1;
                      data_count = 0;
                      }     
                    #endif
 639   3            else
 640   3              {
 641   4              data_count = 0;
 642   4              }
 643   3      
 644   3            #ifdef WX
                    if(receive_data_finished_flag == 1)
                      {
                      receive_data_finished_flag  = 0;
                      switch(received_data_buffer[5])
                        {
                        case ComMode_1:
                          {
                          ID_certificated_flag = 1;
                          After_IDcert_timecount = 0;
                          IDkey_speech_flash = 1;
                          IDcerted_speech();
                          slave_nearby_count = 0;
                          }
                        break;
              
                        case ComMode_11:
                          {
                          Silence_Flag = 1;
                          Self_learn_speech();
                          }
                        break;
              
                        case ComMode_12:
C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 12  

                          {
                          Battery_hint_flag = 1;
                          }
                        break;
                        }
                      }
                    #endif
 675   3            }
 676   2          else
 677   2            {
 678   3            #ifdef ID
 679   3            if(++data_count >= 6)
 680   3              {
 681   4              data_count = 0;
 682   4              IDkey_flash_EN = 1;
 683   4              }
 684   3            #endif
 685   3      
 686   3            #ifdef WX
                    if((data_count == 0)&&(received_data_buffer[0] == CmdHead))
                      {
                      data_count = 1;
                      }
                    else if((data_count == 1)&&(received_data_buffer[1] == ComMode_1))
                      {
                      data_count = 2;
                      }
                    else if(data_count == 2)
                      {
                      data_count = 3;
                      }
                    else if(data_count == 3)
                      {
                      data_count = 4;
                      }
                    else if(data_count == 4)
                      {
                      data_count = 5;
                      }
                    else if(data_count == 5)
                      {
                      data_count = 6;
                      }
                    else if(data_count == 6)
                      {
                      data_count = 0;
                      IDkey_flash_EN = 1;
                      ID_speech();
                      }
                    else
                      {
                      data_count = 0;
                      }
                    #endif
 722   3            }
 723   2          }
 724   1        }
 725          /*---------------------------------------------------
 726            end of file
 727          ----------------------------------------------------*/


C51 COMPILER V9.54   MAIN                                                                  07/07/2017 14:05:20 PAGE 13  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1067    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     60    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     40    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
