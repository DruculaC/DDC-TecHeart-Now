C51 COMPILER V9.54   TIMER                                                                 06/04/2017 11:50:54 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\Timer.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE ..\Library\Timer.c COMPACT ROM(COMPACT) OPTIMIZE(8,SPEED) 
                    -BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND PRINT(.\Timer.lst) TABS(2) OBJECT(.\Timer.obj)

line level    source

   1          /*---------------------------------------------------
   2            Timer.c (v1.00)
   3            
   4            Timer functions
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "Timer.h"
  11          #include "communication.h"
  12          #include "voice.h"
  13          #include "Delay.h"
  14          #include "Battery.h"
  15          #include "AD.h"
  16          #include "Other.h"
  17          #include "operation.h"
  18          #include "hSch51.h"
  19          #include "Elecmotor.h"
*** ERROR C141 IN LINE 19 OF ..\Library\Elecmotor.h: syntax error near '<<'
*** ERROR C129 IN LINE 20 OF ..\Library\Elecmotor.h: missing ';' before '=='
  20          
  21          // ------ Public variable declarations -----------------------------
  22          extern sTaskH hSCH_tasks_G[hSCH_MAX_TASKS];
  23          extern tWord timer0_count;      
  24          extern bit CW_flag;
  25          
  26          // ------ Private variable definitions -----------------------------
  27          tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;   // register value of timer0 and timer1, caculated from 
             -InitTimer()
  28          
  29          
  30          /*--------------------------------------------------
  31            InitTimer()
  32            
  33            初始化定时器T0和T1
  34          ---------------------------------------------------*/
  35          
  36          void InitTimer(const tByte Tick_ms_T0, Tick_us_T1)
  37            {
  38            tLong Inc_T0, Inc_T1;
  39            tWord timer0_16, timer1_16;
  40            
  41            //计算Timer0的寄存器值
  42            Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
  43            timer0_16 = (tWord) (65536UL - Inc_T0);
  44            timer0_8H = (tByte) (timer0_16 / 256);
  45            timer0_8L = (tByte) (timer0_16 % 256);
  46            
  47            //计算Timer1的寄存器值
  48            Inc_T1 = (tLong)Tick_us_T1 * (OSC_FREQ/1000000) / (tLong)OSC_PER_INST;
  49            timer1_16 = (tWord) (65536UL - Inc_T1);
  50            timer1_8H = (tByte) (timer1_16 / 256);
  51            timer1_8L = (tByte) (timer1_16 % 256);
C51 COMPILER V9.54   TIMER                                                                 06/04/2017 11:50:54 PAGE 2   

  52            
  53            TMOD = 0x11;
  54            
  55            TH0 = timer0_8H;
  56            TL0 = timer0_8L;
  57            TH1 = timer1_8H;
  58            TL1 = timer1_8L;
  59          
  60            ET0 = 1;
  61            TR0 = 1;
  62            ET1 = 1;
  63            TR1 = 1;
  64            PT1 = 1;      
  65            EA = 1;
  66            }
  67          
  68          /*-----------------------------------------------------------------
  69            初始化T0，在初始化了串口之后
  70          -----------------------------------------------------------------*/
  71          void InitT0(const tByte Tick_ms_T0)
  72            {
  73            tLong Inc_T0;
  74            tWord timer0_16;
  75             tByte i;
  76            
  77            for (i = 0; i < hSCH_MAX_TASKS; i++) 
  78                {
  79                hSCH_Delete_Task(i);
  80                }
  81            
  82            //计算Timer0的寄存器值
  83            Inc_T0 = (tLong)Tick_ms_T0 * (OSC_FREQ/1000) / (tLong)OSC_PER_INST;
  84            timer0_16 = (tWord) (65536UL - Inc_T0);
  85            timer0_8H = (tByte) (timer0_16 / 256);
  86            timer0_8L = (tByte) (timer0_16 % 256);
  87            
  88             TMOD &= 0xF0;  // Clear all T0 bits (T1 left unchanged)
  89             TMOD |= 0x01;  // Set required T0 bits (T1 left unchanged) 
  90            
  91            hSCH_Manual_Timer0_Reload();
  92             // Interrupt Timer 0 enabled
  93             ET0  = 1;
  94            }
  95          
  96          /*------------------------------------------------------------------*-
  97          
  98            hSCH_Start()
  99          
 100            Starts the scheduler, by enabling interrupts.
 101          
 102            NOTE: Usually called after all regular tasks are added,
 103            to keep the tasks synchronised.
 104          
 105            NOTE: ONLY THE SCHEDULER INTERRUPT SHOULD BE ENABLED!!! 
 106           
 107          -*------------------------------------------------------------------*/
 108          void hSCH_Start(void) 
 109             {
 110             EA = 1;
 111             }
 112          
 113          /*---------------------------------------------------------------------
C51 COMPILER V9.54   TIMER                                                                 06/04/2017 11:50:54 PAGE 3   

 114            sEos_Go_To_Sleep()
 115            将MCU进入休眠状态
 116          ----------------------------------------------------------------------*/
 117          void sEOS_Go_To_Sleep(void)
 118             {
 119             PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 120             }
 121          
 122          
 123          /*------------------------------------------------------------------*-
 124          
 125            hSCH_Manual_Timer0_Reload()
 126          
 127            This scheduler uses a (manually reloaded) 16-bit timer.
 128            The manual reload means that all timings are approximate. 
 129            THIS SCHEDULER IS NOT SUITABLE FOR APPLICATIONS WHERE
 130            ACCURATE TIMING IS REQUIRED!!!
 131            Timer reload is carried out in this function. 
 132           
 133          -*------------------------------------------------------------------*/
 134          void hSCH_Manual_Timer0_Reload()
 135             {
 136             // Stop Timer 0
 137             TR0 = 0;
 138          
 139             // 8051, 12 MHz
 140             // The Timer 0 resolution is 1.000 s
 141             // We set the timer at 64336 to generate interrupt after 1 ms
 142             // -> we are generating timer ticks at ~1 ms intervals
 143             TL0  = timer0_8L;
 144             TH0  = timer0_8H;  
 145          
 146             //  Start Timer 0
 147             TR0  = 1;
 148             }
 149          
 150          /*------------------------------------------------------------------
 151            timerT0()
 152            operation every ticket.
 153          void timer0() interrupt interrupt_timer_0_overflow
 154            {
 155             tByte Index;
 156          
 157             // Reload the timer
 158             hSCH_Manual_Timer0_Reload();
 159             // NOTE: calculations are in *TICKS* (not milliseconds)
 160             for (Index = 0; Index < hSCH_MAX_TASKS; Index++)
 161                {
 162                // Check if there is a task at this location
 163                if (hSCH_tasks_G[Index].pTask)
 164                   {
 165                   if (hSCH_tasks_G[Index].Delay == 0)
 166                      {
 167                      // The task is due to run
 168                      hSCH_tasks_G[Index].RunMe += 1;  // Inc. the 'Run Me' flag
 169          
 170                      if (hSCH_tasks_G[Index].Period)
 171                         {
 172                         // Schedule periodic tasks to run again
 173                         hSCH_tasks_G[Index].Delay = hSCH_tasks_G[Index].Period;
 174                         }
 175                      }
C51 COMPILER V9.54   TIMER                                                                 06/04/2017 11:50:54 PAGE 4   

 176                   else
 177                      {
 178                      // Not yet ready to run: just decrement the delay 
 179                      hSCH_tasks_G[Index].Delay -= 1;
 180                      }
 181                   }         
 182                }
 183            timer0_count += 1;
 184            if(timer0_count > 200)
 185              {
 186              TXD = ~TXD;
 187              timer0_count = 0;
 188              if(CW_flag == 0)
 189                {
 190                CW_flag = 1;
 191                ElecMotor_CW();
 192                }
 193              else
 194                {
 195                CW_flag = 0;
 196                ElecMotor_ACW();      
 197                }
 198              }
 199            
 200            }
 201          --------------------------------------------------------------------*/
 202            
 203          /*---------------------------------------------------
 204            end of file
 205          ----------------------------------------------------*/

C51 COMPILATION COMPLETE.  0 WARNING(S),  2 ERROR(S)
