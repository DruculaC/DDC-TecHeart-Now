C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE Main.c COMPACT ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDI
                    -R(..\Library) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*---------------------------------------------------
   2            main.c (v1.00)
   3          
   4            DDC-Z program, for electrocar.
   5          ----------------------------------------------------*/
   6          
   7          //
   8          #include "Main.h"
   9          #include "port.h"
  10          
  11          #include "AD.h"
  12          #include "voice.h"
  13          #include "pwm.h"
  14          #include "Timer.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          #include "Battery.h"
  18          #include "Other.h"
  19          #include "operation.h"
  20          #include "UART.h"
  21          #include "ISP_DataFlash.h"
  22          #include "schedular.h"
  23          #include "ElecMotor.h"
  24          
  25          
  26          /*------- Public variable declarations --------------------------*/
  27          extern tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;
  28          extern bit enable_sensor_delayEN;
  29          extern bit sensor_EN;
  30          
  31          /*------- Public variable definitions --------------------------*/
  32          bit ID_certificated_flag = 0;     // Flagged once ID card or Slave certificated successfully.
  33          tByte ID_certificated_numbers = 0;  // Numbers of ID certificated.
  34          
  35          bit Host_stolen_alarming = 0;     // Host stolen is alarming, don't detect vibration for 1st stage.
  36          
  37          // ------ Private variable definitions -----------------------------
  38          bit position_sensor_EN=0;     //Î»ÖÃ´«¸ĞÆ÷£¬¼´µ¹µØÌ§Æğ´«¸ĞÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ĞÆ÷
  39          bit EN_host_stolen_alarming = 0;      //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒôÊ¹ÄÜ
  40          bit host_stolen_alarm2_EN = 0;      //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶ş¶ÎÓïÒôÊ¹ÄÜ
  41          tByte host_stolen_alarm1_count = 0;   //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒô´ÎÊı
  42          tByte host_stolen_alarm2_count = 0;   //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶ş¶ÎÓïÒô´ÎÊı
  43          bit fell_flag=0;            //ÅĞ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  44          bit raised_flag=0;          //ÅĞ¶ÏÖ÷»ú±»Ì§Æğºó£¬ÖÃ1
  45          tByte sensor_2ndstage_count = 0;    //´«¸ĞÆ÷½øÈëµÚ¶ş½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  46          tWord sensor_3rdstage_time = 0;     //´«¸ĞÆ÷½øÈëµÚÈı½×¶ÎµÄÊ±¼ä£¬
  47          tByte sensor_3rdstage_effcount = 0;   //´«¸ĞÆ÷½øÈëµÚÈı½×¶Îºó£¬ÓĞĞ§´¥Åö´ÎÊıµÄ¼ÆÊı
  48          tByte sensor_3rdstage_count = 0;      //´«¸ĞÆ÷½øÈëµÚÈı½×¶Îºó£¬µÍµçÆ½µÄ¼ÆÊı
  49          tWord sensor_3rdstage_interval = 0;   //´«¸ĞÆ÷ÔÚµÚÈı½×¶ÎÖĞ£¬Ã¿´ÎÓĞĞ§µÍµçÆ½¼ÆÊıÖ®¼äµÄÊ±¼ä¼ä¸ô¡£ÔÚÕâÆÚ¼äµÄµÍµ
             -çÆ½²»ÈÏÎªÓĞĞ§¡£
  50          bit raised_fell_flag = 0;         //µ¹µØ»òÕßÌ§Æğ´¥·¢ºó£¬´Ë±êÖ¾Î»ÖÃ1
  51          tByte sensor_trigger_count=0;   //´«¸ĞÆ÷´¥·¢¼ÆÊı
  52          tWord sensor_2ndstage_time=0;   //´«¸ĞÆ÷½øÈëµÚ¶ş½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊı
  53          tByte sensor_1ststage_count=0;  //´«¸ĞÆ÷µÚÒ»½×¶ÎÅĞ¶ÏµÍµçÆ½µÄ¼ÆÊı
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 2   

  54          
  55          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æğºó£¬Ïò¸½»ú·¢³ö±¨¾¯ĞÅºÅµÄ´ÎÊı
  56          tByte fell_alarm_count = 0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ĞÅºÅµÄ´ÎÊı
  57          tWord timer0_count=0;   // counter for timer0, increment every ticket       
  58          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //½ÓÊÕÊı¾İ»º´æ
  59          bit receive_data_finished_flag = 0;   //½ÓÊÕÕâÒ»´®Êı¾İÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  60          tByte data_count = 0;       //½ÓÊÕÊı¾İ»º´æµÄÎ»Êı£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊı¾İ
  61          tByte one_receive_byte = 0;   //½ÓÊÕÊı¾İµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  62          tByte one_receive_byte_count = 0;     //one_receive_byteÓĞ8Î»£¬´Ë¼ÆÊı±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊıµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  63          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ĞÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅĞ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕıÈ·µÄÏÂ½µÑØ
  64          tByte receive_HV_count = 0;   //¶¨Ê±Æ÷T1ÔÚÃ»ÓĞĞÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊı£¬Ò»µ©³¬¹ıÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  65          tByte receive_LV_count = 0;   //Ã¿´Îtimer1Òç³öÊ±ÅĞ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊı¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  66          tByte fell_wire_time=0;         //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  67          tByte raise_wire_time=0;      //Ì§Æğ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  68          tWord raised_fell_number = 0;       //µ¹µØ»òÕßÌ§Æğ³ö·¢ºó£¬¼ÆÊı£¬µ½´ïÒ»¶¨ÊıÖµºó£¬½«ÆäÓë±êÖ¾Î»Ò»ÆğÇåÁã¡£
  69          bit raised_fell_once_flag = 0;      //raised_fell_flagÊÇ·ñÔø¾­±êÖ¾¹ı£¬Èç¹û±êÖ¾¹ıÔòÖÃ1.È»ºóÖ÷»ú±»»Ö¸´µ¹µØ»òÕß»
             -Ö¸´Ì§ÆğÊ±£¬´Ë±êÖ¾Î»¸´Î»¡£
  70          tByte Open_action_flag = 0;     //µç¶¯³µ¿ªÆô¹Ø±Õ±êÖ¾Î»£¬1±íÊ¾µç¶¯³µ¿ªÆôÁË£¬0±íÊ¾µç¶¯³µ¹Ø±ÕÁË
  71          tWord ADC_check_result = 0;   //×÷ÎªAD¼ì²âÖµ
  72          
  73          
  74          tWord load_battery_result = 0xfff;
  75          tByte wire_broken_count = 0;    // ×÷Îª¶ÏÏßºóµÄÊ±¼ä¼ì²â
  76          bit battery_stolen_EN = 0;      // ×÷Îªµç³Ø±»µÁµÄÊ¹ÄÜ¶Ë
  77          tByte battery_stolen_count = 0; // ×÷Îªµç³Ø±»µÁµÄ±¨¾¯´ÎÊı
  78          bit horizontal_vibration = 0;   // ±íÊ¾´¹Ö±´«¸ĞÆ÷ÔÚÕñ¶¯£¬´ËÊ±¾ÍËã¹ØÔ¿³×£¬Ò²²»ÄÜÖ´ĞĞ¹ØÔ¿³×µÄ²Ù×÷¡
  79          tWord horizontal_vibration_count = 0; //´¹Ö±´«¸ĞÆ÷´¥·¢ºó£¬¶ÔÊ±¼ä½øĞĞ¼ÆÊı¡£
  80          bit vibration_flag = 0;
  81          tWord vibration_count = 0;
  82          bit wire_broken_flag = 0;     // ¼ô¶ÏËøÏßµÄ±êÖ¾Î»
  83          tByte After_IDcert_timecount = 0;   // ID¿¨ÈÏÖ¤Í¨¹ıºó£¬¼ÆÊ±1·ÖÖÓ£¬Ê¹Ô¿³×ÄÜ×ª¶¯¡£
  84          tByte enable_sensor_delay_count = 0;    // ´«¸ĞÆ÷ÑÓ³ÙµÄÊ±¼ä
  85          bit sensor_3rdalarm_flag = 0;
  86          bit wheeled_flag = 0;
  87          tWord wheeled_count = 0;
  88          bit IDkey_speech_flash = 0;
  89          bit Emergency_open_G = 0;
  90          
  91          bit Speech_closed_G = 0;
  92          tByte Speech_closed_time = 0;
  93          
  94          // If it is a debug program, define IDkey6~11 to RAM
  95          #ifdef Debug
                tByte IDkey6;
                tByte IDkey7;
                tByte IDkey8;
                tByte IDkey9;
                tByte IDkey10;
                tByte IDkey11;
              // If it is a normal program, define IDkey6~11 to Flash ROM
              #else
 104            code tByte IDkey6 _at_ 0x003000;
 105            code tByte IDkey7 _at_ 0x003001;
 106            code tByte IDkey8 _at_ 0x003002;
 107            code tByte IDkey9 _at_ 0x003003;
 108            code tByte IDkey10 _at_ 0x003004;
 109            code tByte IDkey11 _at_ 0x003005;
 110          #endif
 111          
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 3   

 112          tWord IDkey_selflearn_HVcount = 0;
 113          tWord IDkey_selflearn_LVcount = 0;
 114          bit IDkey_selflearn_flag1 = 0;
 115          bit IDkey_selflearn_flag2 = 0;
 116          bit IDkey_selflearn_flag3 = 0;
 117          bit IDkey_selflearn_flag4 = 0;
 118          bit IDkey_selflearn_flag5 = 0;
 119          bit ID_selflearning_flag = 0;
 120          tByte ID_selflearning_timecount = 0;
 121          bit IDkey_flash_EN = 0;
 122          
 123          bit Silence_Flag = 0;
 124          bit flashing_flag = 0;
 125          
 126          tByte Check_Motobattery_count = 0;
 127          bit Check_Motobattery_flag = 0;
 128          bit CheckADC_flag = 0;
 129          
 130          bit never_alarm = 0;
 131          bit never_alarm_speech = 0;
 132          
 133          bit slave_nearby_actioned_flag = 0;
 134          tByte slave_nearby_count = 0;
 135          
 136          bit ID_speeched_flag = 0;
 137          
 138          tByte Stolen_alarm_reset_count = 0;
 139          
 140          bit wire_broken_reset = 0;
 141          
 142          bit Just_power_up = 1;
 143          
 144          bit Battery_hint_flag = 0;
 145          
 146          bit Autolock_G = 0;
 147          tWord timer0_count2 = 0;
 148          
 149          /*------- Private variable declaratuions --------------------------*/
 150          
 151          void main()
 152            {
 153   1        InitVoice();
 154   1      
 155   1        // lock the external motor, prohibit motor moving when power up.
 156   1      //  InitElecmotor();
 157   1      
 158   1        ID_speech();
 159   1      
 160   1        InitUART(BAUD9600);
 161   1      
 162   1        InitSensor();
 163   1      
 164   1        InitTransceiver();
 165   1        
 166   1        
 167   1        // ½«P0.1, P0.2ÉèÖÃ³ÉÊäÈë¸ß×èÄ£Ê½
 168   1        P0M1 |= 0x06;
 169   1        P0M2 &= 0xf9;
 170   1        // ½«P2.5£¬¼´PIN16ÉèÖÃ³ÉÊäÈë¸ß×èÄ£Ê½
 171   1        P2M1 |= 0x20;
 172   1        P2M2 &= 0xdf;
 173   1      
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 4   

 174   1        Lock_EN = 1;
 175   1        
 176   1        // µç»úËø
 177   1        Generator_lock = 0;
 178   1        Externalmotor = 1;
 179   1      
 180   1        lock_power = 0;
 181   1          
 182   1        while(1)
 183   1          {
 184   2          }
 185   1        }
 186          
 187          /*------------------------------------------------------------------
 188            timerT0()
 189            operation every ticket.
 190          --------------------------------------------------------------------*/
 191          void timer0() interrupt interrupt_timer_0_overflow
 192            {
 193   1        // manually reload timer0 configuration
 194   1        TH0 = timer0_8H;
 195   1        TL0 = timer0_8L;
 196   1      
 197   1        // timer0 is 1ms ticket, count the time flow of timer0, then operate every 2s.
 198   1        if(++timer0_count >= 2000)
 199   1          {
 200   2          // reset timer0 ticket counter every 2s
 201   2          timer0_count=0;
 202   2      
 203   2      
 204   2      //    UART_Send_Data_match();
 205   2      
 206   2          #ifdef ID
 207   2          if((++timer0_count2 >= 35)&&(Autolock_G == 0))
 208   2            {
 209   3            Autolock_G = 1;
 210   3            }
 211   2          #endif
 212   2      /*----- Wire_cut detection ----------------------------------------*/
 213   2          if(sensor_EN == 1)
 214   2            {
 215   3            // judge the wire broken, if yes, it means someone has cut the wire of magnet lock
 216   3            if(wire_broken == 0)
 217   3              {
 218   4              EN_host_stolen_alarming = 1;
 219   4              host_stolen_alarm2_EN = 1;
 220   4              Stolen_alarm_reset_count = 0;   
 221   4              wire_broken_flag = 1;
 222   4              }
 223   3            else if((wire_broken == 1)&&(wire_broken_flag == 1))
 224   3              {
 225   4              wire_broken_reset = 1;
 226   4              wire_broken_flag = 0;       
 227   4              ID_speech();
 228   4              }
 229   3            }
 230   2          
 231   2          if(Speech_closed_G == 1)
 232   2            {
 233   3            Speech_closed_time += 1;
 234   3            if(Speech_closed_time > 2)
 235   3              {
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 5   

 236   4              Speech_closed_time = 0;
 237   4              voice_EN = 0;
 238   4              }
 239   3            }
 240   2      
 241   2      /*----- Accumulator relevantly ------------------------------------*/
 242   2          Check_motor_accumulator();
 243   2          Accumulator_voice_promot();
 244   2      
 245   2      /*----- Enable sensor ---------------------------------------------*/
 246   2          #ifdef ID
 247   2          ENsensor_afterIDcert();
 248   2          #endif
 249   2          // if no vibration and wheeled, decrease slave_nearby_count,
 250   2          // if more than 3 times, it means slave is away, then enable sensor.
 251   2          #ifdef WX
                  Ensensor_after_slave_away();
                  #endif    
 254   2      
 255   2          ENsensor_After_Close();
 256   2      
 257   2      /*----- Alarm relevantly -----------------------------------------*/
 258   2          #ifdef Z3
                  Fell_Alarm_to_Slave();
                  Raise_Alarm_to_Slave();
                  Batstolen_Alarm_to_Slave();
                  #endif
 263   2          
 264   2          Host_stolen_action();
 265   2      
 266   2      /*----- Reset flag and disabling sensor relevantly --------------*/
 267   2      
 268   2          Reset_after_wirebroken();
 269   2          Reset_after_stolen_alarming();
 270   2          SelfLearn_Reset();
 271   2          }
 272   1      
 273   1        // Voice hint for entering no guard mode,
 274   1        Enter_noguard_voice();
 275   1      
 276   1      /*----- Detectiong relevantly -----------------------------------*/
 277   1        Detect_selflearn_action();
 278   1        Detect_vibration();
 279   1        Detect_wheel_moving();
 280   1        
 281   1        Disable_sensor_after_IDcert();
 282   1      
 283   1        Detect_open_action();
 284   1        Detect_close_action();  
 285   1        
 286   1        if(Battery_hint_flag == 1)
 287   1          {
 288   2          Battery_hint_flag = 0;
 289   2          Battery_hint();
 290   2          }
 291   1      
 292   1      // judge host is fell or raised every 1ms?
 293   1      //  if((raised_sensor_detect == 1)&&(fell_sensor_detect == 1))
 294   1      //    {
 295   1          // judge vibration sensor is enable?
 296   1          if(sensor_EN == 1)  
 297   1            {     
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 6   

 298   2            // sensor trigger status, 0, 1 or 2?
 299   2            switch(sensor_trigger_count)
 300   2              {
 301   3              // case 0, it means host is in waiting status. waiting for first touch.
 302   3              case 0:
 303   3                {         
 304   4                // judge host been touched and also not in vibration alarm
 305   4      //          if((sensor_detect == 0)&&(Host_stolen_alarming == 0)&&(transmiter_EN == 1))   
 306   4      //          if(((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))&&(Host_stolen_alarming ==
             - 0)&&(flashing_flag == 0)&&(transmiter_EN == 1))    
 307   4                if(((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))&&(Host_stolen_alarming == 0
             -)&&(flashing_flag == 0))    
 308   4                  {
 309   5                  // judge LV is more than 2ms, if yes, it means a effective touch
 310   5                  if(++sensor_1ststage_count >= 1)      
 311   5                    {
 312   6                    sensor_1ststage_count=0;
 313   6                    
 314   6                    
 315   6                    sensor_2ndstage_time = 0;
 316   6                    // sensor trigge status progress to case 1.
 317   6                    sensor_trigger_count = 1;
 318   6                    // alarm speech for first touch
 319   6      //              SCH_Add_Task(host_touch_speech, 0, 0);
 320   6      
 321   6                    // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 322   6                    Generator_lock = 1;
 323   6                    // çµæºéæ­»
 324   6                    Externalmotor = 0;
 325   6      
 326   6                    #ifdef voice
                            host_touch_speech();
                            #endif
 329   6                    
 330   6                    Delay_500ms();Delay_500ms();Delay_500ms();Delay_500ms();
 331   6                           }
 332   5                  }
 333   4                else
 334   4                  {
 335   5                  // if no LV, reset the count.
 336   5                  sensor_1ststage_count = 0;
 337   5                  }
 338   4                }
 339   3              break;
 340   3              
 341   3              // waiting for next touch, 
 342   3              case 1:
 343   3                {
 344   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 345   4                  {
 346   5                  // LV for 2s, means a effective touch
 347   5                  if(++sensor_2ndstage_count >= 1)
 348   5                    {
 349   6                    sensor_2ndstage_count = 0;
 350   6                    sensor_trigger_count = 2;
 351   6                    
 352   6                    sensor_3rdstage_time = 0;
 353   6                    // alarm speech for 2nd touch
 354   6                    
 355   6                    // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 356   6                    Generator_lock = 1;
 357   6                    // çµæºéæ­»
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 7   

 358   6                    Externalmotor = 0;
 359   6                      
 360   6                    #ifdef voice
                            //host_2ndtouch_speech();
                            host_touch_speech();
                            #endif
 364   6                    }
 365   5                  }
 366   4                else
 367   4                  {
 368   5                  sensor_2ndstage_count = 0;
 369   5                  }
 370   4      
 371   4                // if there is no touch in 4s, reset sensor trigger status, etc.
 372   4                if(++sensor_2ndstage_time >= 8000)
 373   4                  {
 374   5                  sensor_trigger_count = 0;
 375   5                  sensor_2ndstage_count = 0;
 376   5                  sensor_1ststage_count = 0;
 377   5                  sensor_2ndstage_time = 0;
 378   5      
 379   5                  // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 380   5                  Generator_lock = 0;
 381   5                  // çµæºéæ­»
 382   5                  Externalmotor = 1;
 383   5                  }
 384   4                }
 385   3              break;
 386   3      
 387   3              case 2:
 388   3                {
 389   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 390   4                  {
 391   5                  // LV for 2s, means a effective touch
 392   5                  if(++sensor_3rdstage_count >= 2)
 393   5                    {
 394   6                    sensor_3rdstage_count = 0;
 395   6                    sensor_trigger_count = 3;
 396   6                    sensor_3rdstage_time = 0;
 397   6      
 398   6                    // alarm speech for 2nd touch
 399   6      //              host_2ndtouch_speech();
 400   6      
 401   6                    // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 402   6                    Generator_lock = 1;
 403   6                    // çµæºéæ­»
 404   6                    Externalmotor = 0;
 405   6      
 406   6                    #ifdef voice
                            host_touch_speech();
                            #endif
 409   6                    }
 410   5                  }
 411   4                else
 412   4                  {
 413   5                  sensor_3rdstage_count = 0;
 414   5                  }
 415   4                  
 416   4                // if there is no touch in 4s, reset sensor trigger status, etc.
 417   4                if(++sensor_3rdstage_time >= 8000)
 418   4                  {
 419   5                  sensor_trigger_count = 0;
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 8   

 420   5                  sensor_3rdstage_count = 0;
 421   5                  sensor_2ndstage_count = 0;
 422   5                  sensor_1ststage_count = 0;
 423   5                  sensor_3rdstage_time = 0;
 424   5      
 425   5                  // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 426   5                  Generator_lock = 0;
 427   5                  // çµæºéæ­»
 428   5                  Externalmotor = 1;
 429   5                  }
 430   4                }
 431   3              break;
 432   3              
 433   3              // waiting for 3rd touch
 434   3              case 3:
 435   3                {
 436   4                if((sensor_detect == 0)||(horizontal_sensor == 0)||(the3rd_sendor == 0))
 437   4                  {
 438   5                  // 2s LV is a effective touch
 439   5                  if(++sensor_3rdstage_count >= 3)
 440   5                    {
 441   6                    sensor_3rdstage_count = 0;
 442   6                    // stolen alarm speech enable
 443   6                    EN_host_stolen_alarming = 1;
 444   6                    host_stolen_alarm2_EN = 1;  
 445   6                    sensor_3rdalarm_flag = 1; 
 446   6                    Stolen_alarm_reset_count = 0;
 447   6                    
 448   6                    // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 449   6                    Generator_lock = 1;
 450   6                    // çµæºéæ­»
 451   6                    Externalmotor = 0;
 452   6                    }
 453   5                  }
 454   4                else
 455   4                  {
 456   5                  sensor_3rdstage_count = 0;
 457   5                  }
 458   4                
 459   4                // if there is no touch in 4s, reset all.
 460   4                if(++sensor_3rdstage_time >= 8000)
 461   4                  {
 462   5                  sensor_trigger_count = 0;
 463   5                  sensor_1ststage_count = 0;
 464   5                  sensor_2ndstage_count = 0;
 465   5                  sensor_2ndstage_time = 0;
 466   5                  sensor_3rdstage_time = 0;
 467   5                  sensor_3rdstage_count = 0;
 468   5                  
 469   5                  if(EN_host_stolen_alarming == 0)
 470   5                    {
 471   6                    // æ¥è­¦æ¶ä½¿æ§å¶å¨ä¾çµ
 472   6                    Generator_lock = 0;
 473   6                    // çµæºéæ­»
 474   6                    Externalmotor = 1;              
 475   6                    }
 476   5                  }
 477   4                }
 478   3              break;
 479   3              }
 480   2            
 481   2            
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 9   

 482   2            if(ADC_check_result < 0x100)
 483   2              {
 484   3              battery_stolen_EN = 1;
 485   3              }
 486   2            else
 487   2              battery_stolen_EN = 0;
 488   2              }
 489   1      //      }
 490   1        
 491   1        // judge whether position sensor is enable
 492   1        if(position_sensor_EN==1)   
 493   1          {
 494   2          // judge whether there is a LV
 495   2          if(raised_sensor_detect == 0) 
 496   2            {
 497   3            // LV > 0.5s means a effective input
 498   3            if(++raise_wire_time==10)
 499   3              {
 500   4              // flag raised, and reset fell
 501   4              raised_flag=1;
 502   4              fell_flag=0;
 503   4              // judge whether there once been a raised or fell.
 504   4              if(raised_fell_once_flag == 0)
 505   4                {
 506   5                // if no, flag raised and fell flag
 507   5                raised_fell_flag = 1;         
 508   5                }
 509   4              }   
 510   3            }
 511   2          else
 512   2            {
 513   3            raised_flag=0;
 514   3            raised_alarm_count=0;
 515   3            raise_wire_time=0;
 516   3            raised_fell_flag = 0;
 517   3            }
 518   2            // judge whether there is a LV
 519   2          if(fell_sensor_detect==0)
 520   2            {
 521   3            // LV > 0.5s means a effective input
 522   3            if(++fell_wire_time==10)  
 523   3              { 
 524   4              //  flag fell, and reset raised
 525   4              fell_flag=1;      
 526   4              raised_flag=0;
 527   4              // judge whether there once been a raised or fell
 528   4              if(raised_fell_once_flag == 0)
 529   4                {
 530   5                raised_fell_flag = 1;         
 531   5                }
 532   4              }   
 533   3            }
 534   2          else
 535   2            {
 536   3            fell_flag=0;
 537   3            fell_alarm_count=0;
 538   3            fell_wire_time=0;
 539   3            raised_fell_flag = 0;
 540   3            }
 541   2          }
 542   1        
 543   1        // judge whether raised or fell, if yes, reset all after 10s.
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 10  

 544   1        if(raised_fell_flag == 1)
 545   1          {
 546   2          if(++raised_fell_number >= 4000)
 547   2            {
 548   3            raised_fell_flag = 0;
 549   3            raised_fell_number = 0;
 550   3            raised_fell_once_flag = 1;
 551   3            
 552   3            sensor_trigger_count = 0;
 553   3            sensor_1ststage_count = 0;
 554   3            sensor_2ndstage_count = 0;
 555   3            sensor_2ndstage_time = 0;
 556   3            sensor_3rdstage_time = 0;
 557   3            sensor_3rdstage_interval = 800;
 558   3            sensor_3rdstage_count = 0;
 559   3            sensor_3rdstage_effcount = 0;         
 560   3            }
 561   2          }
 562   1        }
 563          
 564          /*-----------------------------------------------
 565            UART interrupt
 566          -----------------------------------------------*/
 567          void uart_isr() interrupt 4 
 568            {
 569   1        if(RI)
 570   1          {
 571   2          RI=0;
 572   2          received_data_buffer[data_count] = SBUF;
 573   2      
 574   2          // assign one byte to buffer[i] 
 575   2          
 576   2          if(ID_selflearning_flag == 0)
 577   2            {
 578   3            // judge whether buffer[0] is CmdHead
 579   3            if((data_count == 0) && (received_data_buffer[0] == IDkey6))
 580   3              {
 581   4              data_count = 1;
 582   4              }
 583   3            else if((data_count == 1) && (received_data_buffer[1] == IDkey7))
 584   3              {
 585   4              data_count = 2;
 586   4              }
 587   3            else if((data_count == 2) && (received_data_buffer[2] == IDkey8))
 588   3              {
 589   4              data_count = 3;
 590   4              }
 591   3            else if((data_count == 3) && (received_data_buffer[3] == IDkey9))
 592   3              {
 593   4              data_count = 4;
 594   4              }
 595   3            else if((data_count == 4) && (received_data_buffer[4] == IDkey10))
 596   3              {
 597   4              data_count = 5;
 598   4              }
 599   3            #ifdef ID
 600   3            else if((data_count == 5) && (received_data_buffer[5] == IDkey11))
 601   3              {
 602   4              data_count = 0;
 603   4              ID_certificated_flag = 1;
 604   4              After_IDcert_timecount = 0;
 605   4              IDkey_speech_flash = 1;
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 11  

 606   4              
 607   4              IDcerted_speech();
 608   4                  
 609   4              if(ID_certificated_numbers++ >= 1)
 610   4                {
 611   5                // éé³æ¨¡å¼
 612   5                // Silence_Flag = 1;
 613   5                }
 614   4              if(++ID_certificated_numbers >= 11)
 615   4                {
 616   5                //never_alarm = 1;
 617   5                
 618   5                // Ó¦¼±¿ªËø
 619   5                Emergency_open_G = ~Emergency_open_G;
 620   5                ID_certificated_flag = 1;
 621   5                never_alarm_speech = 1;
 622   5                
 623   5                Silence_Flag = 0;
 624   5                ID_certificated_numbers = 0;
 625   5                }
 626   4              }
 627   3            #endif
 628   3            #ifdef WX
                    else if(data_count == 5)
                      {
                      receive_data_finished_flag = 1;
                      data_count = 0;
                      }     
                    #endif
 635   3            else
 636   3              {
 637   4              data_count = 0;
 638   4              }
 639   3      
 640   3            #ifdef WX
                    if(receive_data_finished_flag == 1)
                      {
                      receive_data_finished_flag  = 0;
                      switch(received_data_buffer[5])
                        {
                        case ComMode_1:
                          {
                          ID_certificated_flag = 1;
                          After_IDcert_timecount = 0;
                          IDkey_speech_flash = 1;
                          IDcerted_speech();
                          slave_nearby_count = 0;
                          }
                        break;
              
                        case ComMode_11:
                          {
                          Silence_Flag = 1;
                          Self_learn_speech();
                          }
                        break;
              
                        case ComMode_12:
                          {
                          Battery_hint_flag = 1;
                          }
                        break;
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 12  

                        }
                      }
                    #endif
 671   3            }
 672   2          else
 673   2            {
 674   3            #ifdef ID
 675   3            if(++data_count >= 6)
 676   3              {
 677   4              data_count = 0;
 678   4              IDkey_flash_EN = 1;
 679   4              }
 680   3            #endif
 681   3      
 682   3            #ifdef WX
                    if((data_count == 0)&&(received_data_buffer[0] == CmdHead))
                      {
                      data_count = 1;
                      }
                    else if((data_count == 1)&&(received_data_buffer[1] == ComMode_1))
                      {
                      data_count = 2;
                      }
                    else if(data_count == 2)
                      {
                      data_count = 3;
                      }
                    else if(data_count == 3)
                      {
                      data_count = 4;
                      }
                    else if(data_count == 4)
                      {
                      data_count = 5;
                      }
                    else if(data_count == 5)
                      {
                      data_count = 6;
                      }
                    else if(data_count == 6)
                      {
                      data_count = 0;
                      IDkey_flash_EN = 1;
                      ID_speech();
                      }
                    else
                      {
                      data_count = 0;
                      }
                    #endif
 718   3            }
 719   2          }
 720   1        }
 721          /*---------------------------------------------------
 722            end of file
 723          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1040    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  06/04/2017 11:00:46 PAGE 13  

   PDATA SIZE       =     60    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     39    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
