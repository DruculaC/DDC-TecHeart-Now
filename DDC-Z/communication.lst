<<<<<<< HEAD
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 1   
=======
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 1   
>>>>>>> c6e65e4f0b4864e969ea86603842dc8b6ee1929b


C51 COMPILER V9.54, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN .\communication.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE ..\Library\communication.c COMPACT ROM(COMPACT) OPTIMIZE(8
                    -,SPEED) BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND PRINT(.\communication.lst) TABS(2) OBJECT(.\communication.obj)

line level    source

   1          /*---------------------------------------------------
   2            communication.c (v1.00)
   3            
   4            通信程序
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "communication.h"
  11          #include "Delay.h"
  12          #include "uart.h"
  13          
  14          /*------ private variable --------------------------*/
  15          tByte myTxRxData[7] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  16          //tByte IDkey11 = IDkey6^IDkey7^IDkey8^IDkey9^IDkey10;
  17          
  18          /*------- Public variable declarations --------------------------*/
  19          extern tByte receive_LV_count;    
  20          extern bit receive_wire_flag;   
  21          extern tByte one_receive_byte;    
  22          extern tByte one_receive_byte_count;      
  23          extern tByte receive_HV_count;    
  24          extern tByte data_count;        
  25          extern tByte received_data_buffer[7];   
  26          extern bit receive_data_finished_flag;    
  27          
<<<<<<< HEAD
  28          #ifdef Debug
                extern tByte IDkey6;
                extern tByte IDkey7;
                extern tByte IDkey8;
                extern tByte IDkey9;
                extern tByte IDkey10;
              #else
  35            extern code tByte IDkey6;
  36            extern code tByte IDkey7;
  37            extern code tByte IDkey8;
  38            extern code tByte IDkey9;
  39            extern code tByte IDkey10;
  40          #endif
  41          
  42          /*----------------------------------------------------
  43            InitTransceiver()
  44            Initialise Transceiver
  45          ----------------------------------------------------*/
  46          void InitTransceiver(void)
  47            {
  48   1        P10 = High;
  49   1        transmiter_EN = Close;
  50   1        receiver_EN = Open; 
  51   1      //  transmiter_power = 0;     // High power mode
  52   1        }
  53            
  54          /*----------------------------------------------------
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 2   

  55            initsignal()  
  56            初始化信号程序，接收机在接接收信号的时候，需要有
  57            一段代码来使接收机打开，而这一段程序有可能无法识别
  58            出来，而是相当于废代码，只占用通信时间。
  59          ----------------------------------------------------*/
  60          void initsignal()
  61            {
  62   1        tByte k,k1;
  63   1        tByte mystartbuffer = 0xaa;
  64   1        for(k1 = 0; k1 < 1; k1++)
  65   1          {
  66   2          for(k=0;k<8;k++)
  67   2            {
  68   3            if((mystartbuffer&0x80) == 0x80)//为1
  69   3              {
  70   4              P10=0;
  71   4              Custom_Delay(46, 20);
  72   4      //        Delay_5ms();
  73   4              }
  74   3            else
  75   3              {
  76   4              P10=0;
  77   4              Custom_Delay(46, 20);
  78   4      //        Delay_5ms();
  79   4              }
  80   3            P10=1;
  81   3            mystartbuffer<<=1;
  82   3            Custom_Delay(40, 24);
  83   3      //      Delay_5ms();
  84   3            }
  85   2          mystartbuffer=0xaa;
  86   2      //    Delay_5ms();
  87   2      //    Custom_Delay(23, 28);
  88   2          }
  89   1        P10=1;
  90   1        }
  91          
  92          void initsignal_F(void)
  93            {
  94   1        tByte k,k1;
  95   1        tByte mystartbuffer = 0xaa;
  96   1        for(k1 = 0; k1 < 1; k1++)
  97   1          {
  98   2          #ifdef Z2
  99   2          for(k=0;k<4;k++)
 100   2          #endif
 101   2          #ifdef Z3
                  for(k=0;k<7;k++)
                  #endif    
 104   2            {
 105   3            if((mystartbuffer&0x80) == 0x80)//为1
 106   3              {
 107   4              P10=0;
 108   4              Custom_Delay(46, 20);
 109   4      //        Delay_5ms();
 110   4              }
 111   3            else
 112   3              {
 113   4              P10=0;
 114   4              Custom_Delay(46, 20);
 115   4      //        Delay_5ms();
 116   4              }
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 3   

 117   3            P10=1;
 118   3            mystartbuffer<<=1;
 119   3            Custom_Delay(40, 24);
 120   3      //      Delay_5ms();
 121   3            }
 122   2          mystartbuffer=0xaa;
 123   2      //    Delay_5ms();
 124   2      //    Custom_Delay(23, 28);
 125   2          }
 126   1        P10=1;
 127   1        }
 128          
 129          /*--------------------------------------------------
 130            Send_Data()
 131            将数据发送出去
 132          --------------------------------------------------*/
 133          void Send_Data(tByte x)
 134            {
 135   1        tByte i,n;
 136   1        for(i=0;i<3;i++)
 137   1          {
 138   2          for(n=0;n<8;n++)
 139   2            {
 140   3            if((myTxRxData[i]&0x80)==0x80)
 141   3              {
 142   4              P10=0;
 143   4              Custom_Delay(36, x);
 144   4              }
 145   3            else
 146   3              {
 147   4              P10=0;
 148   4              Custom_Delay(23, x);
 149   4              }
 150   3            P10=1;
 151   3            myTxRxData[i]<<=1;
 152   3            Custom_Delay(20, x);
 153   3            }
 154   2          } 
 155   1        }
 156          
 157          /*--------------------------------------------------
 158            ComMode_Data()
 159            
 160            主机接收到编码1信号后，会反馈一个编码1信号给附机
 161            以表示主机在附机附近。
 162          ---------------------------------------------------*/
 163          void ComMode_Data(tByte ComMode, x) 
 164            {
 165   1        receiver_EN = 1;
 166   1        Delay(20);
 167   1        transmiter_EN = 0;
 168   1        myTxRxData[0] = CmdHead;
 169   1        myTxRxData[1] = MyAddress;
 170   1        myTxRxData[2] = ComMode;
 171   1      
 172   1        initsignal();
 173   1         Send_Data(x);
 174   1        
 175   1        transmiter_EN = 1;
 176   1        receiver_EN = 1;
 177   1        }
 178          
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 4   
=======
  28          extern code tByte IDkey6;
  29          extern code tByte IDkey7;
  30          extern code tByte IDkey8;
  31          extern code tByte IDkey9;
  32          extern code tByte IDkey10;
  33          
  34          /*----------------------------------------------------
  35             InitTransceiver()
  36             Initialise Transceiver
  37          ----------------------------------------------------*/
  38          void InitTransceiver(void)
  39             {
  40   1         P10 = High;
  41   1         transmiter_EN = Close;
  42   1         receiver_EN = Open;  
  43   1      // transmiter_power = 0;      // High power mode
  44   1         }
  45             
  46          /*----------------------------------------------------
  47             initsignal()
  48             
  49             初始化信号程序，接收机在接接收信号的时候，需要有
  50             一段代码来使接收机打开，而这一段程序有可能无法识别
  51             出来，而是相当于废代码，只占用通信时间。
  52          ----------------------------------------------------*/
  53          void initsignal()
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 2   

  54             {
  55   1         tByte k,k1;
  56   1         tByte mystartbuffer = 0xaa;
  57   1         for(k1 = 0; k1 < 1; k1++)
  58   1            {
  59   2            for(k=0;k<8;k++)
  60   2               {
  61   3               if((mystartbuffer&0x80) == 0x80)//为1
  62   3                  {
  63   4                  P10=0;
  64   4                  Custom_Delay(46, 20);
  65   4      //          Delay_5ms();
  66   4                  }
  67   3               else
  68   3                  {
  69   4                  P10=0;
  70   4                  Custom_Delay(46, 20);
  71   4      //          Delay_5ms();
  72   4                  }
  73   3               P10=1;
  74   3               mystartbuffer<<=1;
  75   3               Custom_Delay(40, 24);
  76   3      //       Delay_5ms();
  77   3               }
  78   2            mystartbuffer=0xaa;
  79   2      //    Delay_5ms();
  80   2      //    Custom_Delay(23, 28);
  81   2            }
  82   1         P10=1;
  83   1         }
  84          
  85          void initsignal_F(void)
  86             {
  87   1         tByte k,k1;
  88   1         tByte mystartbuffer = 0xaa;
  89   1         for(k1 = 0; k1 < 1; k1++)
  90   1            {
  91   2            #ifdef Z2
  92   2            for(k=0;k<4;k++)
  93   2            #endif
  94   2            #ifdef Z3
                    for(k=0;k<7;k++)
                    #endif      
  97   2               {
  98   3               if((mystartbuffer&0x80) == 0x80)//为1
  99   3                  {
 100   4                  P10=0;
 101   4                  Custom_Delay(46, 20);
 102   4      //          Delay_5ms();
 103   4                  }
 104   3               else
 105   3                  {
 106   4                  P10=0;
 107   4                  Custom_Delay(46, 20);
 108   4      //          Delay_5ms();
 109   4                  }
 110   3               P10=1;
 111   3               mystartbuffer<<=1;
 112   3               Custom_Delay(40, 24);
 113   3      //       Delay_5ms();
 114   3               }
 115   2            mystartbuffer=0xaa;
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 3   

 116   2      //    Delay_5ms();
 117   2      //    Custom_Delay(23, 28);
 118   2            }
 119   1         P10=1;
 120   1         }
 121          
 122          /*--------------------------------------------------
 123             Send_Data()
 124             将数据发送出去
 125          --------------------------------------------------*/
 126          void Send_Data(tByte x)
 127             {
 128   1         tByte i,n;
 129   1         for(i=0;i<3;i++)
 130   1            {
 131   2            for(n=0;n<8;n++)
 132   2               {
 133   3               if((myTxRxData[i]&0x80)==0x80)
 134   3                  {
 135   4                  P10=0;
 136   4                  Custom_Delay(36, x);
 137   4                  }
 138   3               else
 139   3                  {
 140   4                  P10=0;
 141   4                  Custom_Delay(23, x);
 142   4                  }
 143   3               P10=1;
 144   3               myTxRxData[i]<<=1;
 145   3               Custom_Delay(20, x);
 146   3               }
 147   2            }  
 148   1         }
 149          
 150          /*--------------------------------------------------
 151             ComMode_Data()
 152             
 153             主机接收到编码1信号后，会反馈一个编码1信号给附机
 154             以表示主机在附机附近。
 155          ---------------------------------------------------*/
 156          void ComMode_Data(tByte ComMode, x) 
 157             {
 158   1         receiver_EN = 1;
 159   1         Delay(20);
 160   1         transmiter_EN = 0;
 161   1         myTxRxData[0] = CmdHead;
 162   1         myTxRxData[1] = MyAddress;
 163   1         myTxRxData[2] = ComMode;
 164   1      
 165   1         initsignal();
 166   1         Send_Data(x);
 167   1         
 168   1         transmiter_EN = 1;
 169   1         receiver_EN = 1;
 170   1         }
 171          
 172          /*--------------------------------------------------
 173             ComMode_Data_WX()
 174             
 175             主机接收到编码1信号后，会反馈一个编码1信号给附机
 176             以表示主机在附机附近。
 177          ---------------------------------------------------*/
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 4   
>>>>>>> c6e65e4f0b4864e969ea86603842dc8b6ee1929b

 179          /*--------------------------------------------------
 180            ComMode_Data_WX()
 181            
 182            主机接收到编码1信号后，会反馈一个编码1信号给附机
 183            以表示主机在附机附近。
 184          ---------------------------------------------------*/
 185          void ComMode_Data_WX(tByte ComMode, x)  
 186            {
 187   1        receiver_EN = 1;
 188   1        Delay(20);
 189   1        transmiter_EN = 0;
 190   1        myTxRxData[0] = CmdHead;
 191   1        myTxRxData[1] = MyAddress;
 192   1        myTxRxData[2] = ComMode;
 193   1      
 194   1        initsignal();
 195   1         Send_Data(x);
 196   1        
 197   1        transmiter_EN = 0;
 198   1        receiver_EN = 0;
 199   1        TXD = 0;
 200   1        }
 201          
 202          /*------------------------------------------------------------------
 203            UART发送数据
 204          ------------------------------------------------------------------*/
 205          void UART_Send_Data(tByte command)
 206            {
 207   1         tByte ii = 0;
 208   1        open_tranceiver();
 209   1        myTxRxData[0] = IDkey6;
 210   1        myTxRxData[1] = IDkey7;
 211   1        myTxRxData[2] = IDkey8;
 212   1        myTxRxData[3] = IDkey9;
 213   1        myTxRxData[4] = IDkey10;
 214   1        myTxRxData[5] = command;
 215   1        
 216   1        initsignal();
 217   1        
 218   1        for(ii = 0; ii < 160; ii++)
 219   1          {
 220   2          SendNByte(myTxRxData, 6);
 221   2          Delay_10ms();   
 222   2          }
 223   1      
 224   1        close_tranceiver();
 225   1        Delay_500ms();
 226   1        }
 227          
 228          /*------------------------------------------------------------------
 229            UART附机发送数据
 230          ------------------------------------------------------------------*/
 231          void UART_Send_Data_F(tByte command)
 232            {
 233   1         tByte ii = 0;
 234   1        open_tranceiver_F();
 235   1      
<<<<<<< HEAD
 236   1        myTxRxData[0] = IDkey6;
 237   1        myTxRxData[1] = IDkey7;
 238   1        myTxRxData[2] = IDkey8;
 239   1        myTxRxData[3] = IDkey9;
 240   1        myTxRxData[4] = IDkey10;
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 5   
=======
 236   1         initsignal_F();   
 237   1         
 238   1         SendNByte(myTxRxData, 6);
 239   1      
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 5   
>>>>>>> c6e65e4f0b4864e969ea86603842dc8b6ee1929b

 241   1        myTxRxData[5] = command;
 242   1      
<<<<<<< HEAD
 243   1        initsignal_F(); 
 244   1        
 245   1        SendNByte(myTxRxData, 6);
 246   1      
 247   1        receiver_EN = 0;
 248   1        close_tranceiver_F();
 249   1      
 250   1        }
 251          
 252          /*------------------------------------------------------------------
 253            UART附机发送数据
 254          ------------------------------------------------------------------*/
 255          void UART_Send_Data_F2(tByte command)
 256            {
 257   1         tByte ii = 0;
 258   1        open_tranceiver_F();
 259   1        myTxRxData[0] = IDkey6;
 260   1        myTxRxData[1] = IDkey7;
 261   1        myTxRxData[2] = IDkey8;
 262   1        myTxRxData[3] = IDkey9;
 263   1        myTxRxData[4] = IDkey10;
 264   1        myTxRxData[5] = command;
 265   1        
 266   1        Delay_1ms();
 267   1        Delay_1ms();
 268   1        Delay_1ms();
 269   1        SendNByte(myTxRxData, 6);
 270   1      
 271   1        receiver_EN = 0;
 272   1        
 273   1        close_tranceiver_F();
 274   1        }
 275          
 276          /*------------------------------------------------------------------
 277            UART附机发送数据
 278          ------------------------------------------------------------------*/
 279          void UART_Send_Data_F3(tByte command)
 280            {
 281   1         tByte ii = 0;
 282   1        myTxRxData[0] = IDkey6;
 283   1        myTxRxData[1] = IDkey7;
 284   1        myTxRxData[2] = IDkey8;
 285   1        myTxRxData[3] = IDkey9;
 286   1        myTxRxData[4] = IDkey10;
 287   1        myTxRxData[5] = command;
 288   1        
 289   1        Delay_1ms();
 290   1        Delay_1ms();
 291   1        Delay_1ms();
 292   1        SendNByte(myTxRxData, 6);
 293   1        }
 294          
 295          /*------------------------------------------------------------------
 296            open_tranceiver()
 297            开发射机
 298          -------------------------------------------------------------------*/
 299          void open_tranceiver(void)
 300            {
 301   1        #ifdef Z3
                InitUART(BAUD1200);
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 6   

                #endif
 304   1        
 305   1        receiver_EN = 1;
 306   1        transmiter_EN = 0;  
 307   1        }
 308          
 309          /*------------------------------------------------------------------
 310            open_tranceiver_F()
 311            开发射机
 312          -------------------------------------------------------------------*/
 313          void open_tranceiver_F(void)
 314            {
 315   1        InitUART(BAUD9600);
 316   1        
 317   1        receiver_EN = 1;
 318   1        transmiter_EN = 0;  
 319   1        }
 320          
 321          /*------------------------------------------------------------------
 322            close_tranceiver()
 323            开发射机
 324          -------------------------------------------------------------------*/
 325          void close_tranceiver(void)
 326            {
 327   1        #ifdef F3
                transmiter_EN = 1;
                #endif
 330   1        
 331   1        receiver_EN = 0;
 332   1        
 333   1        #ifdef Z3
                InitUART(BAUD9600);
                #endif
 336   1        }
 337          /*------------------------------------------------------------------
 338            close_tranceiver_F()
 339            开发射机
 340          -------------------------------------------------------------------*/
 341          void close_tranceiver_F(void)
 342            {
 343   1        #ifdef F3
                transmiter_EN = 1;
                #endif
 346   1        
 347   1        receiver_EN = 0;
 348   1        
 349   1        InitUART(BAUD1200);
 350   1        }
 351          
 352          /*------------------------------------------------------------------
 353            UART发送数据
 354            发送密码，用于主机
 355          ------------------------------------------------------------------*/
 356          void UART_Send_Data_match(void)
 357            {
 358   1        open_tranceiver();
 359   1        
 360   1        myTxRxData[0] = CmdHead;
 361   1        myTxRxData[1] = ComMode_1;
 362   1        myTxRxData[2] = IDkey6;
 363   1        myTxRxData[3] = IDkey7;
 364   1        myTxRxData[4] = IDkey8;
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 7   

 365   1        myTxRxData[5] = IDkey9;
 366   1        myTxRxData[6] = IDkey10;
 367   1        
 368   1        initsignal();
 369   1        
 370   1        SendNByte(myTxRxData, 8);
 371   1        Delay_50ms();
 372   1        
 373   1        close_tranceiver();
 374   1        }
 375          
 376          /*------------------------------------------------------------------
 377            UART_Send_Data_match_F发送数据
 378            发送密码，用于主机
 379          ------------------------------------------------------------------*/
 380          void UART_Send_Data_match_F(void)
 381            {
 382   1        receiver_EN = 1;
 383   1        transmiter_EN = 0;  
 384   1        InitUART(BAUD9600);
 385   1        
 386   1        myTxRxData[0] = CmdHead;
 387   1        myTxRxData[1] = ComMode_1;
 388   1        myTxRxData[2] = IDkey6;
 389   1        myTxRxData[3] = IDkey7;
 390   1        myTxRxData[4] = IDkey8;
 391   1        myTxRxData[5] = IDkey9;
 392   1        myTxRxData[6] = IDkey10;
 393   1        
 394   1        initsignal();
 395   1        
 396   1        SendNByte(myTxRxData, 8);
 397   1        Delay_50ms();
 398   1        
 399   1        receiver_EN = 0;
 400   1        }
 401          
 402          /*-----------------------------------------------------------------------------
 403            receive_byte()
 404            receive a byte program
 405          -----------------------------------------------------------------------------*/
 406          void receive_byte(void)
 407            {
 408   1        // P11 constantly HV, if detected a LV, judge it.
 409   1        if(P11 == 0)
 410   1          {
 411   2          // count the LV time, if more than 12ms, reset it.
 412   2          if(++receive_LV_count >= 120)
 413   2            {
 414   3            receive_LV_count = 0;
 415   3            }
 416   2          receive_wire_flag = 0;
 417   2          }
 418   1        // if P11 return to HV
 419   1        else
 420   1          {
 421   2          // and already have LV before, so we think it maybe a bit signal
 422   2          if(receive_wire_flag == 0)
 423   2            {
 424   3            // set the flag, to judge a bit only one time
 425   3            receive_wire_flag = 1;
 426   3      
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 8   

 427   3            // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 428   3            if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 429   3              {
 430   4              // save "0" to one byte
 431   4              one_receive_byte <<= 1;
 432   4              one_receive_byte &= 0xfe;
 433   4              one_receive_byte_count++;
 434   4              receive_HV_count = 0;
 435   4              }
 436   3            // time > 8ms, means a "1"
 437   3            else if((receive_LV_count > 80))
 438   3              {
 439   4              // save "1" to one byte
 440   4              one_receive_byte <<= 1;
 441   4              one_receive_byte |= 0x01;
 442   4              one_receive_byte_count++;
 443   4              receive_HV_count = 0;
 444   4              }     
 445   3            else
 446   3              {
 447   4              // increase the count for HV
 448   4              receive_HV_count++; 
 449   4              }
 450   3               // reset LV count
 451   3            receive_LV_count = 0;
 452   3            }
 453   2          else
 454   2            {
 455   3            // judge whether HV count > 6ms, if yes, means a restart
 456   3            if(++receive_HV_count >= 60)
 457   3              {
 458   4              one_receive_byte_count = 0;
 459   4              receive_wire_flag = 1;
 460   4              data_count = 0;
 461   4              }   
 462   3            }
 463   2          }
 464   1        }
 465          
 466          /*-----------------------------------------------------------------------------
 467            receive_byte_Lock()
 468            receive a byte program
 469          -----------------------------------------------------------------------------*/
 470          void receive_byte_Lock(void)
 471            {
 472   1        // P11 constantly HV, if detected a LV, judge it.
 473   1        if(receive_wire == 1)
 474   1          {
 475   2          // count the LV time, if more than 12ms, reset it.
 476   2          if(++receive_LV_count >= 120)
 477   2            {
 478   3            receive_LV_count = 0;
 479   3            }
 480   2          receive_wire_flag = 0;
 481   2          }
 482   1        // if P11 return to HV
 483   1        else
 484   1          {
 485   2          // and already have LV before, so we think it maybe a bit signal
 486   2          if(receive_wire_flag == 0)
 487   2            {
 488   3            // set the flag, to judge a bit only one time
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 9   

 489   3            receive_wire_flag = 1;
 490   3      
 491   3            // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 492   3            if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 493   3              {
 494   4              // save "0" to one byte
 495   4              one_receive_byte <<= 1;
 496   4              one_receive_byte &= 0xfe;
 497   4              one_receive_byte_count++;
 498   4              receive_HV_count = 0;
 499   4              }
 500   3            // time > 8ms, means a "1"
 501   3            else if((receive_LV_count > 80))
 502   3              {
 503   4              // save "1" to one byte
 504   4              one_receive_byte <<= 1;
 505   4              one_receive_byte |= 0x01;
 506   4              one_receive_byte_count++;
 507   4              receive_HV_count = 0;
 508   4              }     
 509   3            else
 510   3              {
 511   4              // increase the count for HV
 512   4              receive_HV_count++; 
 513   4              }
 514   3               // reset LV count
 515   3            receive_LV_count = 0;
 516   3            }
 517   2          else
 518   2            {
 519   3            // judge whether HV count > 6ms, if yes, means a restart
 520   3            if(++receive_HV_count >= 60)
 521   3              {
 522   4              one_receive_byte_count = 0;
 523   4              receive_wire_flag = 1;
 524   4              data_count = 0;
 525   4              }   
 526   3            }
 527   2          }
 528   1        }
 529          
 530          /*-----------------------------------------------------------------------------
 531            receive_word()
 532            receive a word program
 533          -----------------------------------------------------------------------------*/
 534          void receive_word(void)
 535            {
 536   1        // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 537   1        if(one_receive_byte_count == 8)
 538   1          {
 539   2          one_receive_byte_count = 0;
 540   2          // assign one byte to buffer[i] 
 541   2          received_data_buffer[data_count] = one_receive_byte;
 542   2          
 543   2          // judge whether buffer[0] is CmdHead
 544   2          if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 545   2            {
 546   3            data_count = 1;
 547   3            }
 548   2          // judge whether buffer[1] is MyAddress
 549   2          else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
 550   2            {
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 10  

 551   3            data_count = 2;
 552   3            }
 553   2          else if(data_count == 2)
 554   2            {
 555   3            receive_data_finished_flag = 1;
 556   3            data_count = 0;
 557   3            }
 558   2          else 
 559   2            {
 560   3            data_count = 0;
 561   3            }
 562   2          }
 563   1        }
 564          
 565          /*--------------------------------------------------
 566            send_code_to_lock()
 567            
 568            将密码发送给锁体。
 569          ---------------------------------------------------*/
 570          void send_code_to_lock(tByte x, y)  
 571          {
 572   1        unsigned char i,n;
 573   1        myTxRxData[0]=CmdHead;
 574   1        myTxRxData[1]=MyAddress;
 575   1        myTxRxData[2]=x;
 576   1      /*  myTxRxData[3]=0x00;
 577   1        myTxRxData[4]=0x00;
 578   1        myTxRxData[5]=0x00;
 579   1        myTxRxData[6]=0x00;
 580   1      */
 581   1        for(i=0;i<3;i++)
 582   1        {
 583   2          for(n=0;n<8;n++)
 584   2          {
 585   3            if((myTxRxData[i]&0x80) == 0x80)//为1
 586   3            {
 587   4              MagentControl_2 = 0;
 588   4              Custom_Delay(36, y);
 589   4            }
 590   3            else//为0的情况
 591   3            {
 592   4              MagentControl_2 = 0;
 593   4              Custom_Delay(23, y);
 594   4            }
 595   3            MagentControl_2 = 1;    //常态为高电平
 596   3            myTxRxData[i] <<= 1;
 597   3            Custom_Delay(15, y);
 598   3          }
 599   2        }
 600   1      }
 601          
 602          /*--------------------------------------------------
 603            send_code_to_lock_Taili()
 604            
 605            将密码发送给锁体。
 606          ---------------------------------------------------*/
 607          void send_code_to_lock_Taili(tByte x, y)  
 608          {
 609   1        unsigned char i,n;
 610   1        myTxRxData[0]=CmdHead;
 611   1        myTxRxData[1]=MyAddress;
 612   1        myTxRxData[2]=x;
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 11  
=======
 243   1         }
 244          
 245          /*------------------------------------------------------------------
 246             UART附机发送数据
 247          ------------------------------------------------------------------*/
 248          void UART_Send_Data_F2(tByte command)
 249             {
 250   1         tByte ii = 0;
 251   1         open_tranceiver_F();
 252   1         myTxRxData[0] = IDkey6;
 253   1         myTxRxData[1] = IDkey7;
 254   1         myTxRxData[2] = IDkey8;
 255   1         myTxRxData[3] = IDkey9;
 256   1         myTxRxData[4] = IDkey10;
 257   1         myTxRxData[5] = command;
 258   1         
 259   1         Delay_1ms();
 260   1         Delay_1ms();
 261   1         Delay_1ms();
 262   1         SendNByte(myTxRxData, 6);
 263   1      
 264   1         receiver_EN = 0;
 265   1         
 266   1         close_tranceiver_F();
 267   1         }
 268          
 269          /*------------------------------------------------------------------
 270             UART附机发送数据
 271          ------------------------------------------------------------------*/
 272          void UART_Send_Data_F3(tByte command)
 273             {
 274   1         tByte ii = 0;
 275   1         myTxRxData[0] = IDkey6;
 276   1         myTxRxData[1] = IDkey7;
 277   1         myTxRxData[2] = IDkey8;
 278   1         myTxRxData[3] = IDkey9;
 279   1         myTxRxData[4] = IDkey10;
 280   1         myTxRxData[5] = command;
 281   1         
 282   1         Delay_1ms();
 283   1         Delay_1ms();
 284   1         Delay_1ms();
 285   1         SendNByte(myTxRxData, 6);
 286   1         }
 287          
 288          /*------------------------------------------------------------------
 289             open_tranceiver()
 290             开发射机
 291          -------------------------------------------------------------------*/
 292          void open_tranceiver(void)
 293             {
 294   1         #ifdef Z3
                 InitUART(BAUD1200);
                 #endif
 297   1         
 298   1         receiver_EN = 1;
 299   1         transmiter_EN = 0;   
 300   1         }
 301          
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 6   

 302          /*------------------------------------------------------------------
 303             open_tranceiver_F()
 304             开发射机
 305          -------------------------------------------------------------------*/
 306          void open_tranceiver_F(void)
 307             {
 308   1         InitUART(BAUD9600);
 309   1         
 310   1         receiver_EN = 1;
 311   1         transmiter_EN = 0;   
 312   1         }
 313          
 314          /*------------------------------------------------------------------
 315             close_tranceiver()
 316             开发射机
 317          -------------------------------------------------------------------*/
 318          void close_tranceiver(void)
 319             {
 320   1         #ifdef F3
                 transmiter_EN = 1;
                 #endif
 323   1         
 324   1         receiver_EN = 0;
 325   1         
 326   1         #ifdef Z3
                 InitUART(BAUD9600);
                 #endif
 329   1         }
 330          /*------------------------------------------------------------------
 331             close_tranceiver_F()
 332             开发射机
 333          -------------------------------------------------------------------*/
 334          void close_tranceiver_F(void)
 335             {
 336   1         #ifdef F3
                 transmiter_EN = 1;
                 #endif
 339   1         
 340   1         receiver_EN = 0;
 341   1         
 342   1         InitUART(BAUD1200);
 343   1         }
 344          
 345          /*------------------------------------------------------------------
 346             UART发送数据
 347             发送密码，用于主机
 348          ------------------------------------------------------------------*/
 349          void UART_Send_Data_match(void)
 350             {
 351   1         open_tranceiver();
 352   1         
 353   1         myTxRxData[0] = CmdHead;
 354   1         myTxRxData[1] = ComMode_1;
 355   1         myTxRxData[2] = IDkey6;
 356   1         myTxRxData[3] = IDkey7;
 357   1         myTxRxData[4] = IDkey8;
 358   1         myTxRxData[5] = IDkey9;
 359   1         myTxRxData[6] = IDkey10;
 360   1         
 361   1         initsignal();
 362   1         
 363   1         SendNByte(myTxRxData, 8);
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 7   

 364   1         Delay_50ms();
 365   1         
 366   1         close_tranceiver();
 367   1         }
 368          
 369          /*------------------------------------------------------------------
 370             UART_Send_Data_match_F发送数据
 371             发送密码，用于主机
 372          ------------------------------------------------------------------*/
 373          void UART_Send_Data_match_F(void)
 374             {
 375   1         receiver_EN = 1;
 376   1         transmiter_EN = 0;   
 377   1         InitUART(BAUD9600);
 378   1         
 379   1         myTxRxData[0] = CmdHead;
 380   1         myTxRxData[1] = ComMode_1;
 381   1         myTxRxData[2] = IDkey6;
 382   1         myTxRxData[3] = IDkey7;
 383   1         myTxRxData[4] = IDkey8;
 384   1         myTxRxData[5] = IDkey9;
 385   1         myTxRxData[6] = IDkey10;
 386   1         
 387   1         initsignal();
 388   1         
 389   1         SendNByte(myTxRxData, 8);
 390   1         Delay_50ms();
 391   1         
 392   1         receiver_EN = 0;
 393   1         }
 394          
 395          /*-----------------------------------------------------------------------------
 396             receive_byte()
 397             receive a byte program
 398          -----------------------------------------------------------------------------*/
 399          void receive_byte(void)
 400             {
 401   1         // P11 constantly HV, if detected a LV, judge it.
 402   1         if(P11 == 0)
 403   1            {
 404   2            // count the LV time, if more than 12ms, reset it.
 405   2            if(++receive_LV_count >= 120)
 406   2               {
 407   3               receive_LV_count = 0;
 408   3               }
 409   2            receive_wire_flag = 0;
 410   2            }
 411   1         // if P11 return to HV
 412   1         else
 413   1            {
 414   2            // and already have LV before, so we think it maybe a bit signal
 415   2            if(receive_wire_flag == 0)
 416   2               {
 417   3               // set the flag, to judge a bit only one time
 418   3               receive_wire_flag = 1;
 419   3      
 420   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 421   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 422   3                  {
 423   4                  // save "0" to one byte
 424   4                  one_receive_byte <<= 1;
 425   4                  one_receive_byte &= 0xfe;
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 8   

 426   4                  one_receive_byte_count++;
 427   4                  receive_HV_count = 0;
 428   4                  }
 429   3               // time > 8ms, means a "1"
 430   3               else if((receive_LV_count > 80))
 431   3                  {
 432   4                  // save "1" to one byte
 433   4                  one_receive_byte <<= 1;
 434   4                  one_receive_byte |= 0x01;
 435   4                  one_receive_byte_count++;
 436   4                  receive_HV_count = 0;
 437   4                  }        
 438   3               else
 439   3                  {
 440   4                  // increase the count for HV
 441   4                  receive_HV_count++;  
 442   4                  }
 443   3               // reset LV count
 444   3               receive_LV_count = 0;
 445   3               }
 446   2            else
 447   2               {
 448   3               // judge whether HV count > 6ms, if yes, means a restart
 449   3               if(++receive_HV_count >= 60)
 450   3                  {
 451   4                  one_receive_byte_count = 0;
 452   4                  receive_wire_flag = 1;
 453   4                  data_count = 0;
 454   4                  }     
 455   3               }
 456   2            }
 457   1         }
 458          
 459          /*-----------------------------------------------------------------------------
 460             receive_byte_Lock()
 461             receive a byte program
 462          -----------------------------------------------------------------------------*/
 463          void receive_byte_Lock(void)
 464             {
 465   1         // P11 constantly HV, if detected a LV, judge it.
 466   1         if(receive_wire == 1)
 467   1            {
 468   2            // count the LV time, if more than 12ms, reset it.
 469   2            if(++receive_LV_count >= 120)
 470   2               {
 471   3               receive_LV_count = 0;
 472   3               }
 473   2            receive_wire_flag = 0;
 474   2            }
 475   1         // if P11 return to HV
 476   1         else
 477   1            {
 478   2            // and already have LV before, so we think it maybe a bit signal
 479   2            if(receive_wire_flag == 0)
 480   2               {
 481   3               // set the flag, to judge a bit only one time
 482   3               receive_wire_flag = 1;
 483   3      
 484   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 485   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 486   3                  {
 487   4                  // save "0" to one byte
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 9   

 488   4                  one_receive_byte <<= 1;
 489   4                  one_receive_byte &= 0xfe;
 490   4                  one_receive_byte_count++;
 491   4                  receive_HV_count = 0;
 492   4                  }
 493   3               // time > 8ms, means a "1"
 494   3               else if((receive_LV_count > 80))
 495   3                  {
 496   4                  // save "1" to one byte
 497   4                  one_receive_byte <<= 1;
 498   4                  one_receive_byte |= 0x01;
 499   4                  one_receive_byte_count++;
 500   4                  receive_HV_count = 0;
 501   4                  }        
 502   3               else
 503   3                  {
 504   4                  // increase the count for HV
 505   4                  receive_HV_count++;  
 506   4                  }
 507   3               // reset LV count
 508   3               receive_LV_count = 0;
 509   3               }
 510   2            else
 511   2               {
 512   3               // judge whether HV count > 6ms, if yes, means a restart
 513   3               if(++receive_HV_count >= 60)
 514   3                  {
 515   4                  one_receive_byte_count = 0;
 516   4                  receive_wire_flag = 1;
 517   4                  data_count = 0;
 518   4                  }     
 519   3               }
 520   2            }
 521   1         }
 522          
 523          /*-----------------------------------------------------------------------------
 524             receive_word()
 525             receive a word program
 526          -----------------------------------------------------------------------------*/
 527          void receive_word(void)
 528             {
 529   1         // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 530   1         if(one_receive_byte_count == 8)
 531   1            {
 532   2            one_receive_byte_count = 0;
 533   2            // assign one byte to buffer[i] 
 534   2            received_data_buffer[data_count] = one_receive_byte;
 535   2            
 536   2            // judge whether buffer[0] is CmdHead
 537   2            if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 538   2               {
 539   3               data_count = 1;
 540   3               }
 541   2            // judge whether buffer[1] is MyAddress
 542   2            else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
 543   2               {
 544   3               data_count = 2;
 545   3               }
 546   2            else if(data_count == 2)
 547   2               {
 548   3               receive_data_finished_flag = 1;
 549   3               data_count = 0;
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 10  

 550   3               }
 551   2            else 
 552   2               {
 553   3               data_count = 0;
 554   3               }
 555   2            }
 556   1         }
 557          
 558          /*--------------------------------------------------
 559             send_code_to_lock()
 560             
 561             将密码发送给锁体。
 562          ---------------------------------------------------*/
 563          void send_code_to_lock(tByte x, y)  
 564          {
 565   1         unsigned char i,n;
 566   1         myTxRxData[0]=CmdHead;
 567   1         myTxRxData[1]=MyAddress;
 568   1         myTxRxData[2]=x;
 569   1      /* myTxRxData[3]=0x00;
 570   1         myTxRxData[4]=0x00;
 571   1         myTxRxData[5]=0x00;
 572   1         myTxRxData[6]=0x00;
 573   1      */
 574   1         for(i=0;i<3;i++)
 575   1         {
 576   2            for(n=0;n<8;n++)
 577   2            {
 578   3               if((myTxRxData[i]&0x80) == 0x80)//为1
 579   3               {
 580   4                  MagentControl_2 = 0;
 581   4                  Custom_Delay(36, y);
 582   4               }
 583   3               else//为0的情况
 584   3               {
 585   4                  MagentControl_2 = 0;
 586   4                  Custom_Delay(23, y);
 587   4               }
 588   3               MagentControl_2 = 1;    //常态为高电平
 589   3               myTxRxData[i] <<= 1;
 590   3               Custom_Delay(15, y);
 591   3            }
 592   2         }
 593   1      }
 594          
 595          /*--------------------------------------------------
 596             send_code_to_lock_Taili()
 597             
 598             将密码发送给锁体。
 599          ---------------------------------------------------*/
 600          void send_code_to_lock_Taili(tByte x, y)  
 601          {
 602   1         unsigned char i,n;
 603   1         myTxRxData[0]=CmdHead;
 604   1         myTxRxData[1]=MyAddress;
 605   1         myTxRxData[2]=x;
 606   1      /* myTxRxData[3]=0x00;
 607   1         myTxRxData[4]=0x00;
 608   1         myTxRxData[5]=0x00;
 609   1         myTxRxData[6]=0x00;
 610   1      */
 611   1         for(i=0;i<3;i++)
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 11  
>>>>>>> c6e65e4f0b4864e969ea86603842dc8b6ee1929b

 613   1      /*  myTxRxData[3]=0x00;
 614   1        myTxRxData[4]=0x00;
 615   1        myTxRxData[5]=0x00;
 616   1        myTxRxData[6]=0x00;
 617   1      */
 618   1        for(i=0;i<3;i++)
 619   1        {
 620   2          for(n=0;n<8;n++)
 621   2          {
 622   3            if((myTxRxData[i]&0x80) == 0x80)//为1
 623   3            {
 624   4              lock_code = 0;
 625   4              Custom_Delay(36, y);
 626   4            }
 627   3            else//为0的情况
 628   3            {
 629   4              lock_code = 0;
 630   4              Custom_Delay(23, y);
 631   4            }
 632   3            lock_code = 1;    //常态为高电平
 633   3            myTxRxData[i] <<= 1;
 634   3            Custom_Delay(15, y);
 635   3          }
 636   2        }
 637   1      }
 638          
 639          /*------------------------------------------------------------------
 640            UART发送数据
 641          ------------------------------------------------------------------*/
 642          void UART_Send_Data_Broadtest(tByte command)
 643            {
 644   1         tByte ii = 0;
 645   1      //  open_tranceiver();
 646   1      
 647   1        myTxRxData[0] = IDkey6;
 648   1        myTxRxData[1] = IDkey7;
 649   1        myTxRxData[2] = IDkey8;
 650   1        myTxRxData[3] = IDkey9;
 651   1        myTxRxData[4] = IDkey10;
 652   1        myTxRxData[5] = command;
 653   1        
 654   1        initsignal();
 655   1        
 656   1        for(ii = 0; ii < 10; ii++)
 657   1          {
 658   2          SendNByte(myTxRxData, 6);
 659   2          Delay_10ms();   
 660   2          }
 661   1      
 662   1      //  close_tranceiver();
 663   1      //  Delay_500ms();
 664   1        }
 665          
 666          
 667          /*---------------------------------------------------
 668            end of file
 669          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1358    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.54   COMMUNICATION                                                         06/04/2017 11:00:44 PAGE 12  

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      7      31
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

<<<<<<< HEAD
=======
C51 COMPILER V9.54   COMMUNICATION                                                         11/14/2016 13:39:14 PAGE 12  

>>>>>>> c6e65e4f0b4864e969ea86603842dc8b6ee1929b

C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
