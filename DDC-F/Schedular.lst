C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE SCHEDULAR
OBJECT MODULE PLACED IN .\Schedular.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE ..\Library\Schedular.c COMPACT ROM(COMPACT) OPTIMIZE
                    -(8,SPEED) BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND PRINT(.\Schedular.lst) TABS(3) OBJECT(.\Schedular.obj)

line level    source

   1          /*------------------------------------------------------------------*-
   2          
   3             hSCH51.C (v1.00) 
   4          
   5            ------------------------------------------------------------------
   6          
   7             /// HYBRID SCHEDULER CORE ///
   8          
   9             *** THESE ARE THE CORE SCHEDULER FUNCTIONS ***
  10             --- These functions may be used with all 8051 devices ---
  11          
  12             *** hSCH_MAX_TASKS *must* be set by the user ***
  13             --- see "Sch51.h" ---
  14          
  15             *** Includes power-saving mode ***
  16             --- You *MUST* confirm that the power-down mode is adapted ---
  17             --- to match your chosen device (usually only necessary with 
  18             --- Extended 8051s, such as c515c, c509, etc ---
  19          
  20             COPYRIGHT
  21             ---------
  22          
  23             This code is from the book:
  24          
  25             PATTERNS FOR TIME-TRIGGERED EMBEDDED SYSTEMS by Michael J. Pont 
  26             [Pearson Education, 2001; ISBN: 0-201-33138-1].
  27          
  28             This code is copyright (c) 2001 by Michael J. Pont.
  29           
  30             See book for copyright details and other information.
  31          
  32          -*------------------------------------------------------------------*/
  33          
  34          #include "Main.h"
  35          #include "Port.h"
  36          
  37          #include "Schedular.h"
  38          
  39          // ------ Public variable definitions ------------------------------
  40          
  41          // The array of tasks
  42          sTaskH hSCH_tasks_G[hSCH_MAX_TASKS];
  43          
  44          // Used to display the error code
  45          // See Main.H for details of error codes
  46          // See Port.H for details of the error port
  47          tByte Error_code_G = 0;
  48          
  49          // ------ Private function prototypes ------------------------------
  50          
  51          static void hSCH_Go_To_Sleep(void);
  52          
  53          // ------ Private variables ----------------------------------------
  54          
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 2   

  55          // Keeps track of time since last error was recorded (see below)
  56          static tWord Error_tick_count_G;
  57          
  58          // The code of the last error (reset after ~1 minute)
  59          static tByte Last_error_code_G;
  60          
  61          
  62          /*------------------------------------------------------------------*-
  63          
  64            hSCH_Dispatch_Tasks()
  65          
  66            This is the 'dispatcher' function.  When a task (function)
  67            is due to run, hSCH_Dispatch_Tasks() will run it.
  68            This function must be called (repeatedly) from the main loop.
  69          
  70          -*------------------------------------------------------------------*/
  71          void hSCH_Dispatch_Tasks(void) 
  72             {
  73   1         tByte Index;
  74   1      
  75   1         // Dispatches (runs) the next task (if one is ready)
  76   1         for (Index = 0; Index < hSCH_MAX_TASKS; Index++)
  77   1            {
  78   2            // Only dispatching co-operative tasks
  79   2            if ((hSCH_tasks_G[Index].Co_op) && (hSCH_tasks_G[Index].RunMe > 0)) 
  80   2               {
  81   3               (*hSCH_tasks_G[Index].pTask)();  // Run the task
  82   3      
  83   3               hSCH_tasks_G[Index].RunMe -= 1;  // Reset / reduce RunMe flag
  84   3      
  85   3               // Periodic tasks will automatically run again
  86   3               // - if this is a 'one shot' task, remove it from the array
  87   3               if (hSCH_tasks_G[Index].Period == 0)
  88   3                  {
  89   4                  // Faster than call to delete task
  90   4                  hSCH_tasks_G[Index].pTask = 0;
  91   4                  }
  92   3               }
  93   2            }
  94   1      
  95   1         // Report system status
  96   1         hSCH_Report_Status();  
  97   1      
  98   1         // The scheduler enters idle mode at this point 
  99   1         hSCH_Go_To_Sleep();          
 100   1         }
 101          
 102          /*------------------------------------------------------------------*-
 103          
 104            hSCH_Add_Task()
 105          
 106            Causes a task (function) to be executed at regular intervals 
 107            or after a user-defined delay
 108          
 109            Fn_P  - The name of the function which is to be scheduled.
 110                    NOTE: All scheduled functions must be 'void, void' -
 111                    that is, they must take no parameters, and have 
 112                    a void return type. 
 113                             
 114            Del   - The interval (TICKS) before the task is first executed
 115          
 116            Rep   - If 'Rep' is 0, the function is only called once,
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 3   

 117                    at the time determined by 'Del'.  If Rep is non-zero,
 118                    then the function is called repeatedly at an interval
 119                    determined by the vakue of Rep (see below for examples
 120                    that should help clarify this).
 121          
 122            Co-op - Set to 1 if it a co-op task; 0 if pre-emptive
 123          
 124            RETN:   The position in the task array at which the task has been added.
 125                    If the return value is hSCH_MAX_TASKS then the task could not be
 126                    added to the array (there was insufficient space).  If the
 127                    return value is < hSCH_MAX_TASKS, then the task was added 
 128                    successfully.  
 129          
 130                    Note: this return value may be required, if a task is
 131                    to be subsequently deleted - see hSCH_Delete_Task().
 132          
 133          
 134            EXAMPLES:
 135          
 136            Task_ID = hSCH_Add_Task(Do_X,1000,0,0);
 137            Causes the function Do_X() to be executed once after 1000 ticks.
 138            (Pre-emptive task)          
 139          
 140            Task_ID = hSCH_Add_Task(Do_X,0,1000,1);
 141            Causes the function Do_X() to be executed regularly, every 1000 ticks.            
 142            (co-operative task)          
 143          
 144            Task_ID = hSCH_Add_Task(Do_X,300,1000,0);
 145            Causes the function Do_X() to be executed regularly, every 1000 ticks.
 146            Task will be first executed at T = 300 ticks, then 1300, 2300, etc.            
 147            (Pre-emptive task)          
 148           
 149          -*------------------------------------------------------------------*/
 150          tByte hSCH_Add_Task(void (code* Fn_p)(), // Task function pointer
 151                             tWord   Del,    // Num ticks 'til task first runs 
 152                             tWord   Per,    // Num ticks between repeat runs
 153                             bit     Co_op,  // Co_op / pre_emp
 154                             tByte   Times)  // process running times
 155             {
 156   1         tByte Index = 0;
 157   1         
 158   1         // First find a gap in the array (if there is one)
 159   1         while ((hSCH_tasks_G[Index].pTask != 0) && (Index < hSCH_MAX_TASKS))
 160   1            {
 161   2            Index++;
 162   2            } 
 163   1         
 164   1         // Have we reached the end of the list?   
 165   1         if (Index == hSCH_MAX_TASKS)
 166   1            {
 167   2            // Task list is full
 168   2            //
 169   2            // Set the global error variable
 170   2            Error_code_G = ERROR_SCH_TOO_MANY_TASKS;
 171   2      
 172   2            // Also return an error code
 173   2            return hSCH_MAX_TASKS;  
 174   2            }
 175   1            
 176   1         // If we're here, there is a space in the task array
 177   1         hSCH_tasks_G[Index].pTask = Fn_p;
 178   1           
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 4   

 179   1         hSCH_tasks_G[Index].Delay = Del;
 180   1         hSCH_tasks_G[Index].Period = Per;
 181   1      
 182   1         hSCH_tasks_G[Index].Co_op = Co_op;
 183   1         hSCH_tasks_G[Index].Times = Times;
 184   1      
 185   1         hSCH_tasks_G[Index].RunMe  = 0;
 186   1      
 187   1         return Index; // return position of task (to allow later deletion)
 188   1         }
 189          
 190          /*------------------------------------------------------------------*-
 191          
 192            hSCH_Delete_Task()
 193          
 194            Removes a task from the scheduler.  Note that this does
 195            *not* delete the associated function from memory: 
 196            it simply means that it is no longer called by the scheduler. 
 197          
 198            PARAMS:   Task_index - The task index.  Provided by hSCH_Add_Task(). 
 199          
 200            RETURNS:  RETURN_ERROR or RETURN_NORMAL
 201          
 202          -*------------------------------------------------------------------*/
 203          bit hSCH_Delete_Task(tByte Task_index) 
 204             {
 205   1         bit Return_code;
 206   1      
 207   1         if (hSCH_tasks_G[Task_index].pTask == 0)
 208   1            {
 209   2            // No task at this location...
 210   2            //
 211   2            // Set the global error variable
 212   2            Error_code_G = ERROR_SCH_CANNOT_DELETE_TASK;
 213   2      
 214   2            // ...also return an error code
 215   2            Return_code = RETURN_ERROR;
 216   2            }
 217   1         else
 218   1            {
 219   2            Return_code = RETURN_NORMAL;
 220   2            }      
 221   1         
 222   1         hSCH_tasks_G[Task_index].pTask   = 0;
 223   1         hSCH_tasks_G[Task_index].Delay   = 0;
 224   1         hSCH_tasks_G[Task_index].Period  = 0;
 225   1         hSCH_tasks_G[Task_index].Times  = 0;
 226   1      
 227   1         hSCH_tasks_G[Task_index].RunMe   = 0;
 228   1      
 229   1         return Return_code;       // return status
 230   1         }
 231          
 232          
 233          /*------------------------------------------------------------------*-
 234          
 235            hSCH_Report_Status()
 236          
 237            Simple function to display error codes.
 238          
 239            This version displays code on a port with attached LEDs:
 240            adapt, if required, to report errors over serial link, etc.
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 5   

 241          
 242            Errors are only displayed for a limited period 
 243            (60000 ticks = 1 minute at 1ms tick interval).
 244            After this the the error code is reset to 0. 
 245          
 246            This code may be easily adapted to display the last
 247            error 'for ever': this may be appropriate in your
 248            application.
 249          
 250            See Chapter 14 for further information.
 251           
 252          -*------------------------------------------------------------------*/
 253          void hSCH_Report_Status(void)
 254             {
 255   1      #ifdef SCH_REPORT_ERRORS
                 // ONLY APPLIES IF WE ARE REPORTING ERRORS
                 // Check for a new error code
                 if (Error_code_G != Last_error_code_G)
                    {
                    // Negative logic on LEDs assumed
                    Error_port = 255 - Error_code_G;
                    
                    Last_error_code_G = Error_code_G;
              
                    if (Error_code_G != 0)
                       {
                       Error_tick_count_G = 60000;
                       }
                    else
                       {
                       Error_tick_count_G = 0;
                       }
                    }
                 else
                    {
                    if (Error_tick_count_G != 0)
                       {
                       if (--Error_tick_count_G == 0)
                          {
                          Error_code_G = 0; // Reset error code
                          }
                       }
                    }
              #endif
 285   1         }
 286          
 287          /*-------------------------------------------------------------
 288             hSCH_Update()
 289             This is the scheduler ISR.  It is called at a rate 
 290             determined by the timer settings in hSCH_Init().
 291             This version is triggered by Timer 0 interrupts:
 292             timer is manually reloaded.
 293          --------------------------------------------------------------*/
 294          void hSCH_Update(void)
 295             {
 296   1         tByte Index;
 297   1         for (Index = 0; Index < hSCH_MAX_TASKS; Index++)
 298   1            {
 299   2            // Check if there is a task at this location
 300   2            if (hSCH_tasks_G[Index].pTask)
 301   2               {
 302   3               if(hSCH_tasks_G[Index].Times)
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 6   

 303   3                  {
 304   4                  if (hSCH_tasks_G[Index].Delay == 0)
 305   4                     {
 306   5                     // The task is due to run
 307   5                     if (hSCH_tasks_G[Index].Co_op)
 308   5                        {
 309   6                        // If it is a co-operative task, increment the RunMe flag
 310   6                        hSCH_tasks_G[Index].RunMe += 1;  
 311   6                        hSCH_tasks_G[Index].Times--;     // Decrease the excuting times
 312   6                        }
 313   5                     else
 314   5                        {
 315   6                        // If it is a pre-emptive task, run it IMMEDIATELY
 316   6                        (*hSCH_tasks_G[Index].pTask)();  // Run the task
 317   6                        hSCH_tasks_G[Index].Times--;     // Decrease the excuting times 
 318   6      
 319   6                        hSCH_tasks_G[Index].RunMe -= 1;   // Reset / reduce RunMe flag
 320   6      
 321   6                        // Periodic tasks will be scheduled again (see below)
 322   6                        // - if this is a 'one shot' task, remove it from the array
 323   6                        if (hSCH_tasks_G[Index].Period == 0)
 324   6                           {
 325   7                           hSCH_tasks_G[Index].pTask  = 0;
 326   7                           }
 327   6                        }
 328   5      
 329   5                     if (hSCH_tasks_G[Index].Period)
 330   5                        {
 331   6                        // Schedule this periodic task to run again
 332   6                        hSCH_tasks_G[Index].Delay = hSCH_tasks_G[Index].Period;
 333   6                        }
 334   5                     }
 335   4                  else
 336   4                     {
 337   5                     // Not yet ready to run: just decrement the delay 
 338   5                     hSCH_tasks_G[Index].Delay -= 1;
 339   5                     }              
 340   4                  }
 341   3               else
 342   3                  hSCH_Delete_Task(Index);
 343   3               }         
 344   2            }  
 345   1         }
 346          
 347          /*-------------------------------------------------------------------
 348             Delete_all_task()
 349          --------------------------------------------------------------------*/
 350          void Delete_all_task(void)
 351             {
 352   1         tByte i;
 353   1         for(i = 0; i <= hSCH_MAX_TASKS; i++)
 354   1            {
 355   2            hSCH_Delete_Task(i);
 356   2            }
 357   1         }
 358             
 359          /*------------------------------------------------------------------*-
 360          
 361            hSCH_Go_To_Sleep()
 362          
 363            This scheduler enters 'idle mode' between clock ticks
 364            to save power.  The next clock tick will return the processor
C51 COMPILER V9.54   SCHEDULAR                                                             05/22/2015 14:12:27 PAGE 7   

 365            to the normal operating state.
 366          
 367            Note: a slight performance improvement is possible if this
 368            function is implemented as a macro, or if the code here is simply 
 369            pasted into the 'dispatch' function.  
 370          
 371            However, by making this a function call, it becomes easier 
 372            - during development - to assess the performance of the 
 373            scheduler, using the 'performance analyser' in the Keil 
 374            hardware simulator. See Chapter 14 for examples for this. 
 375          
 376            *** May wish to disable this if using a watchdog ***
 377          
 378            *** ADAPT AS REQUIRED FOR YOUR HARDWARE ***
 379          
 380          -*------------------------------------------------------------------*/
 381          void hSCH_Go_To_Sleep()
 382             {
 383   1         PCON |= 0x01;    // Enter idle mode (generic 8051 version)
 384   1      
 385   1         // Entering idle mode requires TWO consecutive instructions 
 386   1         // on 80c515 / 80c505 - to avoid accidental triggering
 387   1         //PCON |= 0x01;    // Enter idle mode (#1)
 388   1         //PCON |= 0x20;    // Enter idle mode (#2)
 389   1         }
 390          
 391          
 392          /*------------------------------------------------------------------*-
 393            ---- END OF FILE -------------------------------------------------
 394          -*------------------------------------------------------------------*/
 395          
 396          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    593    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      4       9
   DATA SIZE        =     45    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
