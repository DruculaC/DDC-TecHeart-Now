C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN .\communication.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE ..\Library\communication.c COMPACT ROM(COMPACT) OPTI
                    -MIZE(8,SPEED) BROWSE INCDIR(..\Library) DEBUG OBJECTEXTEND PRINT(.\communication.lst) TABS(3) OBJECT(.\communication.obj
                    -)

line level    source

   1          /*---------------------------------------------------
   2             communication.c (v1.00)
   3             
   4             通信程序
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "communication.h"
  11          #include "Delay.h"
  12          #include "uart.h"
  13          
  14          /*------ private variable --------------------------*/
  15          tByte myTxRxData[7] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  16          //tByte IDkey11 = IDkey6^IDkey7^IDkey8^IDkey9^IDkey10;
  17          
  18          /*------- Public variable declarations --------------------------*/
  19          extern tByte receive_LV_count;      
  20          extern bit receive_wire_flag;    
  21          extern tByte one_receive_byte;      
  22          extern tByte one_receive_byte_count;         
  23          extern tByte receive_HV_count;      
  24          extern tByte data_count;            
  25          extern tByte received_data_buffer[7];     
  26          extern bit receive_data_finished_flag;    
  27          
  28          extern code tByte IDkey6;
  29          extern code tByte IDkey7;
  30          extern code tByte IDkey8;
  31          extern code tByte IDkey9;
  32          extern code tByte IDkey10;
  33          
  34          /*----------------------------------------------------
  35             InitTransceiver()
  36             Initialise Transceiver
  37          void InitTransceiver(void)
  38             {
  39             P10 = High;
  40             transmiter_EN = Close;
  41             receiver_EN = Open;  
  42          // transmiter_power = 0;      // High power mode
  43             }
  44          ----------------------------------------------------*/
  45             
  46          /*----------------------------------------------------
  47             initsignal()
  48             
  49             初始化信号程序，接收机在接接收信号的时候，需要有
  50             一段代码来使接收机打开，而这一段程序有可能无法识别
  51             出来，而是相当于废代码，只占用通信时间。
  52          ----------------------------------------------------*/
  53          void initsignal()
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 2   

  54             {
  55   1         tByte k,k1;
  56   1         tByte mystartbuffer = 0xaa;
  57   1         for(k1 = 0; k1 < 1; k1++)
  58   1            {
  59   2            for(k=0;k<8;k++)
  60   2               {
  61   3               if((mystartbuffer&0x80) == 0x80)//为1
  62   3                  {
  63   4                  P10=0;
  64   4                  Custom_Delay(46, 20);
  65   4      //          Delay_5ms();
  66   4                  }
  67   3               else
  68   3                  {
  69   4                  P10=0;
  70   4                  Custom_Delay(46, 20);
  71   4      //          Delay_5ms();
  72   4                  }
  73   3               P10=1;
  74   3               mystartbuffer<<=1;
  75   3               Custom_Delay(40, 24);
  76   3      //       Delay_5ms();
  77   3               }
  78   2            mystartbuffer=0xaa;
  79   2      //    Delay_5ms();
  80   2      //    Custom_Delay(23, 28);
  81   2            }
  82   1         P10=1;
  83   1         }
  84          
  85          void initsignal_F(void)
  86             {
  87   1         tByte k,k1;
  88   1         tByte mystartbuffer = 0xaa;
  89   1         for(k1 = 0; k1 < 1; k1++)
  90   1            {
  91   2            #ifdef Z2
  92   2            for(k=0;k<4;k++)
  93   2            #endif
  94   2            #ifdef Z3
                    for(k=0;k<7;k++)
                    #endif      
  97   2               {
  98   3               if((mystartbuffer&0x80) == 0x80)//为1
  99   3                  {
 100   4                  P10=0;
 101   4                  Custom_Delay(46, 20);
 102   4      //          Delay_5ms();
 103   4                  }
 104   3               else
 105   3                  {
 106   4                  P10=0;
 107   4                  Custom_Delay(46, 20);
 108   4      //          Delay_5ms();
 109   4                  }
 110   3               P10=1;
 111   3               mystartbuffer<<=1;
 112   3               Custom_Delay(40, 24);
 113   3      //       Delay_5ms();
 114   3               }
 115   2            mystartbuffer=0xaa;
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 3   

 116   2      //    Delay_5ms();
 117   2      //    Custom_Delay(23, 28);
 118   2            }
 119   1         P10=1;
 120   1         }
 121          
 122          /*--------------------------------------------------
 123             Send_Data()
 124             将数据发送出去
 125          --------------------------------------------------*/
 126          void Send_Data(tByte x)
 127             {
 128   1         tByte i,n;
 129   1         for(i=0;i<3;i++)
 130   1            {
 131   2            for(n=0;n<8;n++)
 132   2               {
 133   3               if((myTxRxData[i]&0x80)==0x80)
 134   3                  {
 135   4                  P10=0;
 136   4                  Custom_Delay(36, x);
 137   4                  }
 138   3               else
 139   3                  {
 140   4                  P10=0;
 141   4                  Custom_Delay(23, x);
 142   4                  }
 143   3               P10=1;
 144   3               myTxRxData[i]<<=1;
 145   3               Custom_Delay(20, x);
 146   3               }
 147   2            }  
 148   1         }
 149          
 150          /*--------------------------------------------------
 151             ComMode_Data()
 152             
 153             主机接收到编码1信号后，会反馈一个编码1信号给附机
 154             以表示主机在附机附近。
 155          void ComMode_Data(tByte ComMode, x) 
 156             {
 157             receiver_EN = 1;
 158             Delay(20);
 159             transmiter_EN = 0;
 160             myTxRxData[0] = CmdHead;
 161             myTxRxData[1] = MyAddress;
 162             myTxRxData[2] = ComMode;
 163          
 164             initsignal();
 165             Send_Data(x);
 166             
 167             transmiter_EN = 1;
 168             receiver_EN = 1;
 169             }
 170          ---------------------------------------------------*/
 171          
 172          /*--------------------------------------------------
 173             ComMode_Data_WX()
 174             
 175             主机接收到编码1信号后，会反馈一个编码1信号给附机
 176             以表示主机在附机附近。
 177          void ComMode_Data_WX(tByte ComMode, x) 
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 4   

 178             {
 179             receiver_EN = 1;
 180             Delay(20);
 181             transmiter_EN = 0;
 182             myTxRxData[0] = CmdHead;
 183             myTxRxData[1] = MyAddress;
 184             myTxRxData[2] = ComMode;
 185          
 186             initsignal();
 187             Send_Data(x);
 188             
 189             transmiter_EN = 0;
 190             receiver_EN = 0;
 191             TXD = 0;
 192             }
 193          ---------------------------------------------------*/
 194          
 195          /*------------------------------------------------------------------
 196             UART发送数据
 197          void UART_Send_Data(tByte command)
 198             {
 199             tByte ii = 0;
 200             open_tranceiver();
 201             myTxRxData[0] = IDkey6;
 202             myTxRxData[1] = IDkey7;
 203             myTxRxData[2] = IDkey8;
 204             myTxRxData[3] = IDkey9;
 205             myTxRxData[4] = IDkey10;
 206             myTxRxData[5] = command;
 207             
 208             initsignal();
 209             
 210             for(ii = 0; ii < 160; ii++)
 211                {
 212                SendNByte(myTxRxData, 6);
 213                Delay_10ms();     
 214                }
 215          
 216             close_tranceiver();
 217             Delay_500ms();
 218             }
 219          ------------------------------------------------------------------*/
 220          
 221          /*------------------------------------------------------------------
 222             UART附机发送数据
 223          void UART_Send_Data_F(tByte command)
 224             {
 225             tByte ii = 0;
 226             open_tranceiver_F();
 227          
 228             myTxRxData[0] = IDkey6;
 229             myTxRxData[1] = IDkey7;
 230             myTxRxData[2] = IDkey8;
 231             myTxRxData[3] = IDkey9;
 232             myTxRxData[4] = IDkey10;
 233             myTxRxData[5] = command;
 234          
 235             initsignal_F();   
 236             
 237             SendNByte(myTxRxData, 6);
 238          
 239             receiver_EN = 0;
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 5   

 240             close_tranceiver_F();
 241          
 242             }
 243          ------------------------------------------------------------------*/
 244          
 245          /*------------------------------------------------------------------
 246             UART附机发送数据
 247          void UART_Send_Data_F2(tByte command)
 248             {
 249             tByte ii = 0;
 250             open_tranceiver_F();
 251             myTxRxData[0] = IDkey6;
 252             myTxRxData[1] = IDkey7;
 253             myTxRxData[2] = IDkey8;
 254             myTxRxData[3] = IDkey9;
 255             myTxRxData[4] = IDkey10;
 256             myTxRxData[5] = command;
 257             
 258             Delay_1ms();
 259             Delay_1ms();
 260             Delay_1ms();
 261             SendNByte(myTxRxData, 6);
 262          
 263             receiver_EN = 0;
 264             
 265             close_tranceiver_F();
 266             }
 267          ------------------------------------------------------------------*/
 268          
 269          /*------------------------------------------------------------------
 270             UART附机发送数据
 271          void UART_Send_Data_F3(tByte command)
 272             {
 273             tByte ii = 0;
 274             myTxRxData[0] = IDkey6;
 275             myTxRxData[1] = IDkey7;
 276             myTxRxData[2] = IDkey8;
 277             myTxRxData[3] = IDkey9;
 278             myTxRxData[4] = IDkey10;
 279             myTxRxData[5] = command;
 280             
 281             Delay_1ms();
 282             Delay_1ms();
 283             Delay_1ms();
 284             SendNByte(myTxRxData, 6);
 285             }
 286          ------------------------------------------------------------------*/
 287          
 288          /*------------------------------------------------------------------
 289             open_tranceiver()
 290             开发射机
 291          void open_tranceiver(void)
 292             {
 293             #ifdef Z3
 294             InitUART(BAUD1200);
 295             #endif
 296             
 297             receiver_EN = 1;
 298             transmiter_EN = 0;   
 299             }
 300          -------------------------------------------------------------------*/
 301          
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 6   

 302          /*------------------------------------------------------------------
 303             open_tranceiver_F()
 304             开发射机
 305          void open_tranceiver_F(void)
 306             {
 307             InitUART(BAUD9600);
 308             
 309             receiver_EN = 1;
 310             transmiter_EN = 0;   
 311             }
 312          -------------------------------------------------------------------*/
 313          
 314          /*------------------------------------------------------------------
 315             close_tranceiver()
 316             开发射机
 317          void close_tranceiver(void)
 318             {
 319             #ifdef F3
 320             transmiter_EN = 1;
 321             #endif
 322             
 323             receiver_EN = 0;
 324             
 325             #ifdef Z3
 326             InitUART(BAUD9600);
 327             #endif
 328             }
 329          -------------------------------------------------------------------*/
 330          /*------------------------------------------------------------------
 331             close_tranceiver_F()
 332             开发射机
 333          void close_tranceiver_F(void)
 334             {
 335             #ifdef F3
 336             transmiter_EN = 1;
 337             #endif
 338             
 339             receiver_EN = 0;
 340             
 341             InitUART(BAUD1200);
 342             }
 343          -------------------------------------------------------------------*/
 344          
 345          /*------------------------------------------------------------------
 346             UART发送数据
 347             发送密码，用于主机
 348          void UART_Send_Data_match(void)
 349             {
 350             open_tranceiver();
 351             
 352             myTxRxData[0] = CmdHead;
 353             myTxRxData[1] = ComMode_1;
 354             myTxRxData[2] = IDkey6;
 355             myTxRxData[3] = IDkey7;
 356             myTxRxData[4] = IDkey8;
 357             myTxRxData[5] = IDkey9;
 358             myTxRxData[6] = IDkey10;
 359             
 360             initsignal();
 361             
 362             SendNByte(myTxRxData, 8);
 363             Delay_50ms();
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 7   

 364             
 365             close_tranceiver();
 366             }
 367          ------------------------------------------------------------------*/
 368          
 369          /*------------------------------------------------------------------
 370             UART_Send_Data_match_F发送数据
 371             发送密码，用于主机
 372          void UART_Send_Data_match_F(void)
 373             {
 374             receiver_EN = 1;
 375             transmiter_EN = 0;   
 376             InitUART(BAUD9600);
 377             
 378             myTxRxData[0] = CmdHead;
 379             myTxRxData[1] = ComMode_1;
 380             myTxRxData[2] = IDkey6;
 381             myTxRxData[3] = IDkey7;
 382             myTxRxData[4] = IDkey8;
 383             myTxRxData[5] = IDkey9;
 384             myTxRxData[6] = IDkey10;
 385             
 386             initsignal();
 387             
 388             SendNByte(myTxRxData, 8);
 389             Delay_50ms();
 390             
 391             receiver_EN = 0;
 392             }
 393          ------------------------------------------------------------------*/
 394          
 395          /*-----------------------------------------------------------------------------
 396             receive_byte()
 397             receive a byte program
 398          -----------------------------------------------------------------------------*/
 399          void receive_byte(void)
 400             {
 401   1         // P11 constantly HV, if detected a LV, judge it.
 402   1         if(P11 == 0)
 403   1            {
 404   2            // count the LV time, if more than 12ms, reset it.
 405   2            if(++receive_LV_count >= 120)
 406   2               {
 407   3               receive_LV_count = 0;
 408   3               }
 409   2            receive_wire_flag = 0;
 410   2            }
 411   1         // if P11 return to HV
 412   1         else
 413   1            {
 414   2            // and already have LV before, so we think it maybe a bit signal
 415   2            if(receive_wire_flag == 0)
 416   2               {
 417   3               // set the flag, to judge a bit only one time
 418   3               receive_wire_flag = 1;
 419   3      
 420   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 421   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 422   3                  {
 423   4                  // save "0" to one byte
 424   4                  one_receive_byte <<= 1;
 425   4                  one_receive_byte &= 0xfe;
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 8   

 426   4                  one_receive_byte_count++;
 427   4                  receive_HV_count = 0;
 428   4                  }
 429   3               // time > 8ms, means a "1"
 430   3               else if((receive_LV_count > 80))
 431   3                  {
 432   4                  // save "1" to one byte
 433   4                  one_receive_byte <<= 1;
 434   4                  one_receive_byte |= 0x01;
 435   4                  one_receive_byte_count++;
 436   4                  receive_HV_count = 0;
 437   4                  }        
 438   3               else
 439   3                  {
 440   4                  // increase the count for HV
 441   4                  receive_HV_count++;  
 442   4                  }
 443   3               // reset LV count
 444   3               receive_LV_count = 0;
 445   3               }
 446   2            else
 447   2               {
 448   3               // judge whether HV count > 6ms, if yes, means a restart
 449   3               if(++receive_HV_count >= 60)
 450   3                  {
 451   4                  one_receive_byte_count = 0;
 452   4                  receive_wire_flag = 1;
 453   4                  data_count = 0;
 454   4                  }     
 455   3               }
 456   2            }
 457   1         }
 458          
 459          /*-----------------------------------------------------------------------------
 460             receive_byte_Lock()
 461             receive a byte program
 462          -----------------------------------------------------------------------------*/
 463          void receive_byte_Lock(void)
 464             {
 465   1         // P11 constantly HV, if detected a LV, judge it.
 466   1         if(receive_wire == 1)
 467   1            {
 468   2            // count the LV time, if more than 12ms, reset it.
 469   2            if(++receive_LV_count >= 120)
 470   2               {
 471   3               receive_LV_count = 0;
 472   3               }
 473   2            receive_wire_flag = 0;
 474   2            }
 475   1         // if P11 return to HV
 476   1         else
 477   1            {
 478   2            // and already have LV before, so we think it maybe a bit signal
 479   2            if(receive_wire_flag == 0)
 480   2               {
 481   3               // set the flag, to judge a bit only one time
 482   3               receive_wire_flag = 1;
 483   3      
 484   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 485   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 486   3                  {
 487   4                  // save "0" to one byte
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 9   

 488   4                  one_receive_byte <<= 1;
 489   4                  one_receive_byte &= 0xfe;
 490   4                  one_receive_byte_count++;
 491   4                  receive_HV_count = 0;
 492   4                  }
 493   3               // time > 8ms, means a "1"
 494   3               else if((receive_LV_count > 80))
 495   3                  {
 496   4                  // save "1" to one byte
 497   4                  one_receive_byte <<= 1;
 498   4                  one_receive_byte |= 0x01;
 499   4                  one_receive_byte_count++;
 500   4                  receive_HV_count = 0;
 501   4                  }        
 502   3               else
 503   3                  {
 504   4                  // increase the count for HV
 505   4                  receive_HV_count++;  
 506   4                  }
 507   3               // reset LV count
 508   3               receive_LV_count = 0;
 509   3               }
 510   2            else
 511   2               {
 512   3               // judge whether HV count > 6ms, if yes, means a restart
 513   3               if(++receive_HV_count >= 60)
 514   3                  {
 515   4                  one_receive_byte_count = 0;
 516   4                  receive_wire_flag = 1;
 517   4                  data_count = 0;
 518   4                  }     
 519   3               }
 520   2            }
 521   1         }
 522          
 523          /*-----------------------------------------------------------------------------
 524             receive_word()
 525             receive a word program
 526          -----------------------------------------------------------------------------*/
 527          void receive_word(void)
 528             {
 529   1         // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 530   1         if(one_receive_byte_count == 8)
 531   1            {
 532   2            one_receive_byte_count = 0;
 533   2            // assign one byte to buffer[i] 
 534   2            received_data_buffer[data_count] = one_receive_byte;
 535   2            
 536   2            // judge whether buffer[0] is CmdHead
 537   2            if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 538   2               {
 539   3               data_count = 1;
 540   3               }
 541   2            // judge whether buffer[1] is MyAddress
 542   2            else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
 543   2               {
 544   3               data_count = 2;
 545   3               }
 546   2            else if(data_count == 2)
 547   2               {
 548   3               receive_data_finished_flag = 1;
 549   3               data_count = 0;
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 10  

 550   3               }
 551   2            else 
 552   2               {
 553   3               data_count = 0;
 554   3               }
 555   2            }
 556   1         }
 557          
 558          /*--------------------------------------------------
 559             send_code_to_lock()
 560             
 561             将密码发送给锁体。
 562          void send_code_to_lock(tByte x, y)  
 563          {
 564             unsigned char i,n;
 565             myTxRxData[0]=CmdHead;
 566             myTxRxData[1]=MyAddress;
 567             myTxRxData[2]=x;
 568          /* myTxRxData[3]=0x00;
 569             myTxRxData[4]=0x00;
 570             myTxRxData[5]=0x00;
 571             myTxRxData[6]=0x00;
 572          
 573             for(i=0;i<3;i++)
 574             {
 575                for(n=0;n<8;n++)
 576                {
 577                   if((myTxRxData[i]&0x80) == 0x80)//为1
 578                   {
 579                      MagentControl_2 = 0;
 580                      Custom_Delay(36, y);
 581                   }
 582                   else//为0的情况
 583                   {
 584                      MagentControl_2 = 0;
 585                      Custom_Delay(23, y);
 586                   }
 587                   MagentControl_2 = 1;    //常态为高电平
 588                   myTxRxData[i] <<= 1;
 589                   Custom_Delay(15, y);
 590                }
 591             }
 592          }
 593          ---------------------------------------------------*/
 594          
 595          /*--------------------------------------------------
 596             send_code_to_lock_Taili()
 597             
 598             将密码发送给锁体。
 599          void send_code_to_lock_Taili(tByte x, y)  
 600          {
 601             unsigned char i,n;
 602             myTxRxData[0]=CmdHead;
 603             myTxRxData[1]=MyAddress;
 604             myTxRxData[2]=x;
 605          /* myTxRxData[3]=0x00;
 606             myTxRxData[4]=0x00;
 607             myTxRxData[5]=0x00;
 608             myTxRxData[6]=0x00;
 609          
 610             for(i=0;i<3;i++)
 611             {
C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 11  

 612                for(n=0;n<8;n++)
 613                {
 614                   if((myTxRxData[i]&0x80) == 0x80)//为1
 615                   {
 616                      lock_code = 0;
 617                      Custom_Delay(36, y);
 618                   }
 619                   else//为0的情况
 620                   {
 621                      lock_code = 0;
 622                      Custom_Delay(23, y);
 623                   }
 624                   lock_code = 1;    //常态为高电平
 625                   myTxRxData[i] <<= 1;
 626                   Custom_Delay(15, y);
 627                }
 628             }
 629          }
 630          ---------------------------------------------------*/
 631          
 632          /*------------------------------------------------------------------
 633             UART发送数据
 634          void UART_Send_Data_Broadtest(tByte command)
 635             {
 636             tByte ii = 0;
 637          // open_tranceiver();
 638          
 639             myTxRxData[0] = IDkey6;
 640             myTxRxData[1] = IDkey7;
 641             myTxRxData[2] = IDkey8;
 642             myTxRxData[3] = IDkey9;
 643             myTxRxData[4] = IDkey10;
 644             myTxRxData[5] = command;
 645             
 646             initsignal();
 647             
 648             for(ii = 0; ii < 10; ii++)
 649                {
 650                SendNByte(myTxRxData, 6);
 651                Delay_10ms();     
 652                }
 653          
 654          // close_tranceiver();
 655          // Delay_500ms();
 656             }
 657          ------------------------------------------------------------------*/
 658          
 659          
 660          /*---------------------------------------------------
 661             end of file
 662          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    517    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      7       9
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.54   COMMUNICATION                                                         11/15/2016 11:49:21 PAGE 12  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
